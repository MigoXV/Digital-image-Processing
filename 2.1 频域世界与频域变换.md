[TOC]

# 2.1 频域世界与频域变换

时域和频域之间的变换可用数学公式表示如下：
$$
f(f){\Leftrightarrow} A(f), \Phi(f)\tag{2-1}
$$
为能同时表示信号的振幅和相位，通常采用复数表示法，因此式（2-1）可用复数表示为 
$$
f(f)\Leftrightarrow F(f)\tag{2-2}
$$
完成这种变换，一般采用的方法是线性正交变换。



 2.5 离散沃尔什-哈达玛变换（WHT） 2.5.1 一维离散沃尔什-哈达玛变换        1. 沃尔什函数        沃尔什函数是1923年由美国数学家沃尔什提出的。沃尔什函数系是一个完备正交函数系，其值只能取＋1和－1。从排列次序上可将沃尔什函数分为三种定义方法：一种是按照沃尔什排列来定义（按列率排序）；另一种是按照佩利排列来定义（按自然排序）；第三种是按照哈达玛排列来定义。由于哈达玛排序的沃尔什函数是由2n（n=0，1，2，…）阶哈达玛矩阵（Hadamard Matrix）得到的，而哈达玛矩阵的最大优点在于它具有简单的递推关系， 即高阶矩阵可用两个低阶矩阵的克罗内克积求得，因此在此只介绍哈达玛排列定义的沃尔什变换。         N=2n(n=0, 1, 2, …)阶哈达玛矩阵每一行的符号变化规律对应于某一个沃尔什函数的符号变化规律，即N=2n(n=0, 1, 2, …)阶哈达玛矩阵的每一行对应于一个离散沃尔什函数，哈达玛矩阵与沃尔什函数系不同之处仅仅是行的次序不同。2n阶哈达玛矩阵有如下形式： (2-64) (2-65) (2-66)         哈达玛矩阵的阶数是按N＝2n(n＝0, 1, 2, …)规律排列的，阶数较高的哈达玛矩阵，可以利用矩阵的克罗内克积运算，由低阶哈达玛矩阵递推得到，即 （2-67）         矩阵的克罗内克积(Kronecker Product) 运算用符号记作A⊙B， 其运算规律如下：        设 则 (2-68) (2-69) 2. 离散沃尔什-哈达玛变换一维离散沃尔什变换定义为 (2-70) 一维离散沃尔什逆变换定义为 (2-71) 式中，Walsh(u, x)为沃尔什函数。若将Walsh(u, x)用哈达玛矩阵表示，并将变换表达式写成矩阵形式，则式（2-70）和式（2-71）分别为 和 (2-72) (2-73) 式中，［HN］为N阶哈达玛矩阵。         由哈达玛矩阵的特点可知，沃尔什-哈达玛变换的本质上是将离散序列f(x)的各项值的符号按一定规律改变后，进行加减运算， 因此，它比采用复数运算的DFT和采用余弦运算的DCT要简单得多。 2.5.2 二维离散沃尔什变换        很容易将一维WHT的定义推广到二维WHT。二维WHT的正变换核和逆变换核分别为 (2-74) 和 (2-75) 式中：x,  u=0,  1,  2,  …,  M－1； y,  v=0,  1,  2,  …,  N－1。 二维离散沃尔什变换的矩阵形式表达式为 和 求这两个信号的二维WHT。 根据题意，式（2-76）中的M=N=4， 其二维WHT变换核为 所以 再如，图2-12是一幅数字图像及对其进行二维WHT变换的结果。图2-12 二维WHT结果（a）原图像；（b）WHT结果 ![Picture 24](C:\Users\16955\Desktop\academiic\image\Picture 24.jpeg)         注： 图2-12中的结果是按哈达玛变换后再用沃尔什排序的结果。        从以上例子可看出，二维WHT具有能量集中的特性，而且原始数据中数字越是均匀分布，经变换后的数据越集中于矩阵的边角上。因此，二维WHT可用于压缩图像信息。 2.5.3 快速沃尔什变换（FWHT）         类似于FFT，WHT也有快速算法FWHT， 也可将输入序列f(x)按奇偶进行分组，分别进行WHT。FWHT的基本关系为 (2-78)         WHT的变换核是可分离和对称的， 因此二维WHT也可分为两个一维的WHT分别用FWHT进行变换而得到最终结果，由此便可实现二维的FWHT。         综上所述，WHT是将一个函数变换成取值为＋1或－1的基本函数构成的级数，用它来逼近数字脉冲信号时要比FFT有利。同时， WHT只需要进行实数运算，存储量比FFT要少得多， 运算速度也快得多。因此，WHT在图像传输、 通信技术和数据压缩中被广泛使用。 2.6  用Matrix<LIB>C++库实现图像变换的VC++编程 2.6.1 Matrix<LIB>简介及其与VC++工程的集成         1. Matrix<LIB>简介        Matrix<Lib>C++数学库是MathTools公司利用Matcom技术开发的一个面向专业从事工程技术和科学计算人员的矩阵运算动态链接库。这个C++库提供了绝大多数的关于矩阵类、矩阵操作、 数值计算等函数的定义，它提供了一个双精度Matrix类型——Mm， 它可以定义的矩阵是复数矩阵、实数矩阵、稀疏矩阵甚至n维矩阵。同时还提供了近千个与矩阵运算相关的函数，并对如＋、－、 *、 /、 ()等操作符进行了重载。库中所提供的函数涉及线性代数、多项式数学、信号处理、文件输入／输出、绘图等各个方面。充分利用这些库函数， 便可完成数字图像变换的各种操作。         2. 在C++工程中集成Matrix<LIB>C++数学库       为了将Matrix<LIB>C++库集成到C++的工程文件中，需要做如下的操作：     （1） 将库文件v4501v.lib库文件添加到C++的工程中；     （2） 将库声明头文件matlib.h包含到工程中；     （3） 初始化库；     （4） 创建矩阵变量；     （5） 访问矩阵单元；     （6） 调用Matrix<LIB>C++库函数完成矩阵操作。         为了使读者掌握如何在VC++中使用Matrix<LIB>C++数学库的方法，下面详细介绍从创建工程到最后调用Matrix<LIB>C++库函数的全过程。        1） 创建一个新的VC++工程[HTSS]        在VC++中，采用默认选项创建一个MDI MFC工程。当然Matrix<LIB>C++库可以用在任何其他类型的工程中，如Console 、 OWL、ActiveX等。         2） 将库文件添加到工程中        为使C++编译器能够将Matrix<LIB>C++库链接到最后的执行文件中去，必须将Matrix<LIB>C++库加入到C++的工程文件中。用菜单命令Project/Add to Project/Files…将C:＼matcom45＼lib＼v4501v.lib（如果v4501v.lib存在不同的文件夹中，请选择正确的路径）加入到C++工程中。        3） 包含matlib.h头文件        在要使用Matrix<LIB>C++库的.h或.cpp文件的头部， 将matlib.h头文件包含到工程中，即在使用Matrix<LIB>C++库的.h或.cpp文件头部添加如下代码：        #include "matlib.h”        同时用菜单命令Tools/Options…/Directories设置matlib.h所在的路径，以便编译器能找到相应的头文件。         4）初始化Matrix<LIB>C++库        在调用Matrix<LIB>C++库函数之前，要用"initM(MATCOM_VERSION)"函数来初始化类库调用，并用"exitM()"函数来结束类库调用， 故还应在.cpp 中加入下列代码：             initM(MATCOM_VERSION);            	 //用Matrix<LIB>C++库函数的调用完成矩阵操作	exitM();             当然可以在一个类的构造函数中添加            initM(MATCOM_VERSION); …以完成类库的初始化工作。        可在该类的析构函数中添加        exitM(); 以完成结束类库调用的工作。        MATCOM_VERSION参数是一个在matlib.h头文件中定义的值为4501的常量（不同版本其值有所差异）， 它保证了动态链接库与matlib.h的匹配。         5） 创建矩阵变量        添加了Matrix<LIB>C++库后，可用关键字Mm来定义中矩阵类型变量， 例如：         Mm a ,  b,  x;          这条VC++语句在当前工程文件中创建了a、b、x三个矩阵变量，但这时a、b和x还只是空的矩阵， 它们的矩阵单元还不包含任何的值。          6） 访问矩阵单元        矩阵单元的访问包括读和写操作，主要有：通过.r()来访问矩阵的实部，通过.i()来访问矩阵的虚部； 通过BR()函数把一个数据列表赋给矩阵各个单元；通过.addr()或.addi()返回矩阵变量的实部或虚部的内存指针来完成对矩阵单元的访问。         3. 安装与Matrix<LIB>C++库对应的动态链接库        当采用Matrix<LIB>C++数学库完成矩阵的运算时， 要求系统中有相关的ago4501.dll, v4501v.dll, opengl32.dll和glu32.dll四个动态链接库文件。如果系统中安装有Matcom4.5，这些动态链接库文件将会自动安装在window＼system\或window＼system32＼下， 如果系统没有安装Matcom4.5， 只需将这四个动态链接库文件拷贝到相应目录下即可。 2.6.2 创建图像数据矩阵       为利用矩阵运算完成图像变换， 首先应将其图像数据赋给矩阵变量。       设指针pBits指向读入内存中的图像数据首地址， 可用如下代码将图像数据赋给矩阵变量（为简单起见， 设图像为8位灰度图像）。         1. 在类定义头文件.h中定义矩阵变量         Mm m_matBits;         2. 在类实现文件.cpp中完成对矩阵变量的赋值操作         //图像数据总字节数， 其中nWidthBytes为每行图像数据占用的字节数         DWORD SizeImage = nWidthBytes * nHeight;          //通过创建一个1×SizeImage的一维0矩阵， 为矩阵变量分配内存         m_matBits = zeros(1,  SizeImage);          //将矩阵由double型转换为unsigned char型， 以便将图像数据赋给矩阵         m_matBits = muint8(m_matBits);         //首先利用m_matBits.addr()获得矩阵实部的内存指针， 然后利用memcpy()将图像数据一次性          //赋给矩阵变量         memcpy(m_matBits.addr(),  pBits,  SizeImage);         //由于Mm型的矩阵在内存中是按先列后行的顺序存储的， 因此， 应先用Matrix<LIB>C++的库        //函数reshape()将一维矩阵m_matBits变为nHeight×nWidthBytes的二维矩阵， 再用rot90()函数        //将其逆时针旋转90°， 将矩阵变为nWidthBytes×nHeight的二维矩阵        m_matBits = rot90(reshape(m_matBits,  nWidthBytes,  nHeight));         //若图像宽度与其字节宽度不同， 则将由系统补齐的每行字节数为4的整数倍的各列0删除，以减 小矩阵大小加快处理速度 if(nWidthBytes != nWidth){      m_matBits = m_matBits(c_p,  colon(1,  1,  nWidth)); }//将矩阵由unsigned char型转换为double型， 以便进行运算m_matBits = mdouble(m_matBits); 2.6.3 将矩阵数据赋给图像数据区        为使数据符合图像文件格式，还应将处理后的矩阵数据赋给图像数据区，其代码如下： //检查m_matBits矩阵是否为空if(isempty(m_matBits) == 1){    return FALSE; }//将矩阵数据范围限定于0～255之间m_matBits = mabs(m_matBits); Mm L = m_matBits > 255.0; Mm NotL = !L; m_matBits = times(m_matBits,  NotL) + L * 255.0; //将矩阵由double型转换为unsigned char型， 以便将图像数据赋给矩阵m_matBits = muint8(m_matBits); //计算nWidth/4的余数int nTmp = (int)rem(nWidth,  4); int nPadding; //为矩阵各列补0， 以使其为符合4的整数倍if(nTmp > 0){  nPadding = 4 - nTmp;   m_matBits = cat(2,  m_matBits,    repmat(muint8(0),  (BR(size(m_matBits,  1)),  nPadding))); }//将矩阵顺时针旋转90°m_matBits = rot90(m_matBits,  -1); //将图像数据赋绘矩阵memcpy(pBits,  m_matBits.addr(),  (nWidthBytes * nHeight)*sizeof(unsigned char)); 2.6.4 利用矩阵运算进行图像变换       图像数据矩阵建立后，便可利用Matrix<LIB>C++的库函数通过各种矩阵运算完成图像变换的工作。        1. 离散傅立叶变换        Matrix<LIB>C++的库提供了函数dft()、fft()和fft2()分别用于完成一维DFT、 一维FFT和二维FFT运算，函数ifft()和ifft2()用于完成一维FFT和二维FFT的逆傅立叶变换。在图像处理中常用的函数是fft2()和ifft2()，利用这两个函数便可分别完成图像的正、反傅立叶变换。其核心代码如下： //调用Matrix<Lib>C++库函数fft2()完成二维离散傅立叶变换Mm ff = fft2(m_matBits); //调用Matrix<Lib>C++库函数fftshift()将频域中心移到矩阵中心ff = fftshift(ff); //调用Matrix<Lib>C++库函数mabs()计算频谱m_matBits = mabs(ff);         2. 离散余弦变换        在Matrix<LIB>C++库中并未提供离散余弦变换函数，因此需要编写相应的变换函数。由式（7-61）和式（7-63）可知， 利用离散傅立叶正反变换便可完成离散余弦正反变换，实际上Matlab提供的dct（）、 idct（）、 dct2（）和idct2（）函数就是如此完成离散余弦正反变换的。仔细阅读相应的.m文件便可得出其实现变换的过程， 这样就可以编写用以完成一维DCT函数dct()的代码。完成一维离散余弦变换函数dct()后，利用二维DCT的可分离性，便可方便的编制出用于二维离散余弦变换函数dct2()。其核心代码为         b = transpose(dct(transpose(dct(arg1))));        其中， arg1为待变换矩阵。        同理， 可编制出一维IDCT函数变换idct()和二维IDCT函数idct2()。        与图像的离散傅立叶变换类似， 实现图像的离散余弦变换的代码如下：        Mm ff = dct2(m_matBits);         //调用Matrix<Lib>C++库函数mabs()计算频谱        m_matBits = mabs(ff);          3. 离散沃尔什-哈达玛变换        同样，在Matrix<LIB>C++库中并未提供离散沃尔什-哈达玛变换的函数，但它提供了用于产生哈达玛矩阵的函数hadamard()， 其语法为        H=hadamard(N); 其中的元素为1或－1， 注意该矩阵只有当n或n/12或n/20为2的整次幂时才存在。        利用矩阵形式的WHT， 可由如下代码完成离散沃尔什-哈达玛变换：        //获得矩阵的行数和列数Mm mSize = size(m_matBits); //生成哈达玛矩阵Mm HColum = hadamard(mSize.r(1, 1)); Mm HRow = hadamard(mSize.r(1, 2));  //进行离散哈达玛变换Mm ff = HRow * m_matBits * HColum; //调整系数以便以图像方式显示结果ff = ff * 1000/(mSize.r(1, 1)*mSize.r(1, 2)); //调用Matrix<Lib>C++库函数mabs()计算频谱m_matBits = mabs(ff); 2.7 小波变换简介 2.7.1 小波变换的理论基础        信号分析是为了获得时间和频率之间的相互关系。傅立叶变换提供了有关频率域的信息，但有关时间的局部化信息却基本丢失。与傅立叶变换不同，小波变换是通过缩放母小波（Mother wavelet）的宽度来获得信号的频率特征， 通过平移母小波来获得信号的时间信息。对母小波的缩放和平移操作是为了计算小波系数，这些小波系数反映了小波和局部信号之间的相关程度。         1. 连续小波变换（CWT）        像傅立叶分析一样，小波分析就是把一个信号分解为将母小波经过缩放和平移之后的一系列小波，因此小波是小波变换的基函数。小波变换可以理解为用经过缩放和平移的一系列小波函数代替傅立叶变换的正弦波和余弦波进行傅立叶变换的结果。        图7-13表示了正弦波和小波的区别，由此可以看出，正弦波从负无穷一直延续到正无穷，正弦波是平滑而且是可预测的， 而小波是一类在有限区间内快速衰减到0的函数，其平均值为0， 小波趋于不规则、不对称。 图2-13 正弦波和小波（a） 正弦波曲线； (b) 小波曲线         从小波和正弦波的形状可以看出，变化剧烈的信号，用不规则的小波进行分析比用平滑的正弦波更好，即用小波更能描述信号的局部特征。        连续小波变换（Continuous Wavelet Transform， CWT）用下式表示： (2-79)         式（2-79）表示小波变换是信号f(x)与被缩放和平移的小波函数ψ()之积在信号存在的整个期间里求和的结果。CWT的变换结果是许多小波系数C，这些系数是缩放因子（scale）和平移（positon）的函数。         基本小波函数ψ()的缩放和平移操作含义如下：        (1) 缩放。简单地讲， 缩放就是压缩或伸展基本小波， 缩放系数越小， 则小波越窄，如图2-14所示。 图2-14 小波的缩放操作         (2) 平移。简单地讲，平移就是小波的延迟或超前。在数学上， 函数f(t)延迟k的表达式为f(t-k)，如图2-15所示。 图2-15 小波的平移操作(a) 小波函数ψ(t)； (b) 位移后的小波函数ψ(t-k)         CWT计算主要有如下五个步骤：        第一步： 取一个小波， 将其与原始信号的开始一节进行比较。         第二步： 计算数值C， C表示小波与所取一节信号的相似程度，计算结果取决于所选小波的形状， 如图2-16所示。        第三步：向右移动小波，重复第一步和第二步，直至覆盖整个信号，如图2-17所示。         第四步： 伸展小波， 重复第一步至第三步， 如图2-18所示。 图2-16 计算系数值C 图2-17  计算平移后系数值C 图2-18  计算尺度后系数值C        第五步：对于所有缩放，重复第一步至第四步。       小波的缩放因子与信号频率之间的关系是：缩放因子scale越小，表示小波越窄，度量的是信号的细节变化，表示信号频率越高；缩放因子scale越大， 表示小波越宽，度量的是信号的粗糙程度，表示信号频率越低。          2. 离散小波变换（DWT）        在每个可能的缩放因子和平移参数下计算小波系数，其计算量相当大， 将产生惊人的数据量，而且有许多数据是无用的。如果缩放因子和平移参数都选择为2j（j>0且为整数）的倍数， 即只选择部分缩放因子和平移参数来进行计算， 就会使分析的数据量大大减少。使用这样的缩放因子和平移参数的小波变换称为双尺度小波变换（Dyadic Wavelet Transform），它是离散小波变换（Discrete Wavelet Transform， DWT）的一种形式。通常离散小波变换就是指双尺度小波变换。         执行离散小波变换的有效方法是使用滤波器， 该方法是Mallat于1988年提出的，称为Mallat算法。这种方法实际上是一种信号分解的方法， 在数字信号处理中常称为双通道子带编码。        用滤波器执行离散小波变换的概念如图2-19所示。S表示原始的输入信号， 通过两个互补的滤波器组， 其中一个滤波器为低通滤波器，通过该滤波器可得到信号的近似值A（Approximations），另一个为高通滤波器， 通过该滤波器可得到信号的细节值D（Detail）。图2-19 小波分解示意图        在小波分析中，近似值是大的缩放因子计算的系数，表示信号的低频分量，而细节值是小的缩放因子计算的系数，表示信号的高频分量。实际应用中，信号的低频分量往往是最重要的，而高频分量只起一个修饰的作用。如同一个人的声音一样， 把高频分量去掉后，听起来声音会发生改变，但还能听出说的是什么内容，但如果把低频分量删除后，就会什么内容也听不出来了。         由图2-19可以看出离散小波变换可以表示成由低通滤波器和高通滤波器组成的一棵树。原始信号经过一对互补的滤波器组进行的分解称为一级分解，信号的分解过程也可以不断进行下去，也就是说可以进行多级分解。如果对信号的高频分量不再分解，而对低频分量进行连续分解，就可以得到信号不同分辨率下的低频分量， 这也称为信号的多分辨率分析。如此进行下去， 就会形成图2-20所示的一棵比较大的分解树， 称其为信号的小波分解树（Wavelet  Decomposition Tree）。实际中， 分解的级数取决于要分析的信号数据特征及用户的具体需要。图2-20 多级信号分解示意图（a） 信号分解； (b) 小波分数； （c）小波分解树 图2-21 小波分解下采样示意图          3. 小波重构        将信号的小波分解的分量进行处理后，一般还要根据需要把信号恢复出来，也就是利用信号的小波分解的系数还原出原始信号，这一过程称为小波重构（Wavelet Reconstruction）或叫做小波合成（Wavelet Synthesis）。这一合成过程的数学运算叫做逆离散小波变换（Inverse Discrete Wavelet Transform， IDWT）。 图2-22 小波重构算法示意图         1）重构近似信号与细节信号       由图2-22可知，由小波分解的近似系数和细节系数可以重构出原始信号。同样，可由近似系数和细节系数分别重构出信号的近似值或细节值，这时只要近似系数或细节系数置为零即可。        图2-23是对第一层近似信号或细节信号进行重构的示意图。 图2-23 重构近似和细节信号示意（a） 重构近似信号； (b) 重构细节信号         2）多层重构        在图2-23中，重构出信号的近似值A1与细节值D1之后，则原信号可用A1＋D1＝S重构出来。对应于信号的多层小波分解，小波的多层重构如图2-24所示。由图2-24可见重构过程为：A3＋D3＝A2；A2＋D2＝A1；A1+D1＝S。        信号重构中，滤波器的选择非常重要，关系到能否重构出满意的原始信号。低通分解滤波器（L）和高通分解滤波器（H）及重构滤波器组（L′和H′）构成一个系统， 这个系统称为正交镜像滤波器（Quadrature Mirror Filters， QMF）系统， 如图7-25所示。图2-24 多层小波重构示意图图2-25 多层小波分解和重构示意图         4. 小波包分析        小波分析是将信号分解为近似与细节两部分，近似部分又可以分解成第二层近似与细节，可以这样重复下去。对于一个N层分解来说， 有N+1个分解信号的途径。        而小波包分析的细节与近似部分一样，也可以分解，对于N层分解，它产生2N个不同的途径，图2-26是一个小波包分解示意图。 图2-26 小波包分解示意图         小波包分解也可得到一个分解树， 称其为小波包分解树（Wavelet Packet Decomposition Tree）， 这种树是一个完整的二叉树。小波包分解方法是小波分解的一般化， 可为信号分析提供更丰富和更详细的信息。信号S可表示为AA2＋ADA3＋DDA3＋D1等。        5. 二维离散小波变换        二维离散小波变换是一维离散小波变换的推广， 其实质上是将二维信号在不同尺度上的分解， 得到原始信号的近似值和细节值。由于信号是二维的，因此分解也是二维的。分解的结果为： 近似分量cA、 水平细节分量cH、 垂直细节分量cV和对角细节分量cD。同样也可以利用二维小波分解的结果在不同尺度上重构信号。二维小波分解和重构过程如图2-27所示。 图2-27 二维小波分解和重构过程示意图（a） 二维DWT； (b) 二维IDWT 7.7.2 离散小波变换在图像处理中的应用简介         1. 用小波变换进行图像分解        使用小波变换完成图像分解的方法很多，例如，均匀分解（Uniform decomposition）、非均匀分解（Non-uniform decomposition）、八带分解（Octave-band decomposition）、小波包分解（Wavelet-packer decomposition）等。其中八带分解是使用最广的一种分解方法，这种分解方法把低频部分分解成比较窄的频带，而对每一级分解得到的高频部分不再进一步进行分解。图2-28为八带分解示意图， 用于分解的原始图像采用Matlab提供的预存图像文件woman2.mat，小波基函数为“haar”小波。图2-28（c）是用Matlab的小波工具箱编程进行分解得到的图像。 图2-28 八带分解示意图(a) 一次二维DWT； (b) 两次二维DWT； (c) Woman二级分解图 2. 用小波变换进行图像处理         对静态二维数字图像，可先对其进行若干次二维DWT变换， 将图像信息分解为高频成分H、V和D和低频成分A。对低频部分A，由于它对压缩的结果影响很大，因此可采用无损编码方法， 如Huffman、 DPCM等；对H、V和D部分，可对不同的层次采用不同策略的向量量化编码方法，这样便可大大减少数据量，而图像的解码过程刚好相反。整个编码、解码流程如图2-29所示。 图2-29 图像压缩编码、 解码流程         此外，还可以在对A、H、V和D部分编码后加上一个反馈环节， 获取误差图像，并对其编码。这样压缩效果会更好。        近年来，基于小波变换发展起来的图像编码有嵌入式零树小波编码EZW（Embedded Zerotree Wavelet）及在EZW算法基础上改进的层树分级编码SPIHT（Set Parition In HierarchicalTrees）和最佳截断嵌入码块编码EBCOT（Embedded Block Coding with Optimized Truncation)等。ISO/IEC JTC1 SC29小组制定的JPEG2000静态图像编码标准中的图像变换技术就采用了离散小波变换，这些编码的最大特点是在不丢失重要信息的同时， 能以较高的比率压缩图像数据， 并且其算法计算量小。 