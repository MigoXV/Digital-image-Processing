\title{
2.6 用Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库实现图像 变换的VC++编程
}

\subsubsection{Matrix $<\mathrm{LIB}>$ 简介及其与 $\mathrm{VC}++$ 工程的集成}

\section{Matrix $<\mathbf{L I B}>$ 简介}

Matrix $<\mathrm{Lib}>\mathrm{C}++$ 数学库是MathTools公司利用Matcom技术开发的一个面向 专业从事工程技术和科学计算人员的矩阵运算动态链接库。这个C++库提供了 绝大多数的关于矩阵类、矩阵操作、数值计算等函数的定义, 它提供了一个双 精度Matrix类型- Mm, 它可以定义的矩阵是复数矩阵、实数矩阵、稀疏矩阵 甚至 $n$ 维矩阵。同时还提供了近千个与矩阵运算相关的函数，并对如十、一、， /、()等操作符进行了重载。库中所提供的函数涉及线性代数、多项式数学、信 号处理、文件输入 / 输出、绘图等各个方面。充分利用这些库函数, 便可完成 数字图像变换的各种操作。 

\section{2. 在 $\mathrm{C}++$ 工程中集成Matrix $<\mathrm{LIB}>\mathrm{C}++$ 数学库}

为了将 Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库集成到 $\mathrm{C}++$ 的工程文件中, 需要做 如下的操作:

（1） 将库文件v4501v.lib库文件添加到 $\mathrm{C}++$ 的 工程中;

（2）将库声明头文件matlib.h包含到工程中;

（3）初始化库;

（4）创建矩阵变量;

(5) 访问矩阵单元;

（6）调用Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库函数完成矩阵操作。 

\section{为了使读者掌握如何在 $\mathrm{VC}++$ 中使用 $M a t r i x<\mathrm{LIB}>\mathrm{C}++$ 数学库}

的方法, 下面详细介绍从创建工程到最后调用 Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库函数的全过程。

\section{1）创建一个新的 $\mathrm{VC}++$ 工程 $[\mathrm{HTSS}]$}

在VC++中，采用默认选项创建一个MDI MFC工程。当然

\section{Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库可以用在任何其他类型的工程中，如Console 、}

\section{OWL、ActiveX等。}



\section{2）将库文件添加到工程中}

\section{为使 $\mathrm{C}++$ 编译器能够将 Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库链接到最后的执}

行文件中去, 必须将Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库加入到 $\mathrm{C}++$ 的工程文件

中。用菜单命令Project/Add to Project/Files...将C: \matcom45\

lib v4501v.lib（如果v4501v.lib存在不同的文件夹中, 请选择

正确的路径）加入到C++工程中。 

\title{
3）包含matlib.h头文件
}

在要使用 Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库的.h或.cpp文件的头部, 将 matlib.h头文件包含到工程中, 即在使用 Matrix $<L I B>C++$ 库的. $h$ 或.cpp文件头部添加如下代码:

\author{
\#include "matlib.h"
}

同时用菜单命令Tools/Options.../Directories设置matlib.h所在

的路径, 以便编译器能找到相应的头文件。 
4) 初始化Matrix $<$ LIB $>$ C ++ 库

在 调 用 Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库函数 之前，要用 "initM(MATCOM_VERSION)"函数来初始化类库调用, 并用 "exitM()"函数来结束类库调用, 故还应在.cpp 中加入下列代码:

\section{initM(MATCOM_VERSION);}

\section{//用Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库函数的调用完成矩阵操作}

\section{exitM();}

当然可以在一个类的构造函数中添加

initM(MATCOM_VERSION); 以完成类库的初始化工作。

\section{可在该类的析构函数中添加}

\section{exitM()}

以完成结束类库调用的工作。

\section{MATCOM_VERSION参数是一个在matlib.h头文件中定义的}

\section{值为4501的常量（不同版本其值有所差异），它保证了动态链}

接库与matlib.h的匹配。 

\section{5）创建矩阵变量}

添加了 Matrix $<\mathrm{LIB}>\mathrm{C}++$ 库后, 可用关键字 Mm来定义中矩

阵类型变量, 例如:

Mm a , b, x;

这条 $\mathrm{VC}++$ 语句在当前工程文件中创建了 $\mathrm{a} 、 \mathrm{~b} 、 \mathrm{x}$ 三个矩阵

变量, 但这时 $a 、 b$ 和 $x$ 还只是空的矩阵, 它们的矩阵单元还不 包含任何的值。 

\section{6）访问矩阵单元}

\section{矩阵单元的访问包括读和写操作, 主要有: 通过.r()来访问}

矩阵的实部, 通过. i()来访问矩阵的虚部; 通过 $\mathrm{BR}()$ 函数把一个

数据列表赋给矩阵各个单元; 通过.addr()或.addi()返回矩阵变量

的实部或虚部的内存指针来完成对矩阵单元的访问。 

\section{3. 安装与Matrix $<$ LIB $>C++$ 库对应的动态链接库}

当采用Matrix $<\mathrm{LIB}>\mathrm{C}++$ 数学库完成矩阵的运算时, 要求系

\section{统中有相关的ago4501.dll，v4501v.dll，opengl32.dll和glu32.dll四个} 动态链接库文件。如果系统中安装有Matcom4.5, 这些动态链接

库文件将会自动安装在window \system।或window \system32

下, 如果系统没有安装Matcom4.5, 只需将这四个动态链接库文

\section{件拷贝到相应目录下即可。}



\subsection{2 创建图像数据矩阵}

\section{为利用矩阵运算完成图像变换, 首先应将其图像数据赋给}

矩阵变量。

设指针pBits指向读入内存中的图像数据首地址, 可用如下 代码将图像数据赋给矩阵变量 (为简单起见, 设图像为8位灰 度图像）。

\section{1. 在类定义头文件.h中定义矩阵变量}

Mm m_matBits; 

\section{2. 在类实现文件.cpp中完成对矩阵变量的赋值操作}

//图像数据总字节数, 其中nWidthBytes为每行图像数据占用的字节数

\section{DWORD SizeImage $=$ nWidthBytes * nHeight;}

//通过创建一个 $1 \times$ SizeImage的一维 0 矩阵, 为矩阵变量分配内存

m_matBits = zeros $(1$, SizeImage $)$

//将矩阵由double型转换为unsigned char型, 以便将图像数据赋给矩阵

m_matBits $=$ muint8(m_matBits);

//首先利用m_matBits.addr()获得矩阵实部的内存指针, 然后利用memcpy() 将图像数据一次性 //赋给矩阵变量

memcpy(m_matBits.addr(), pBits, SizeImage);

//由于 $\mathrm{Mm}$ 型的矩阵在内存中是按先列后行的顺序存储的, 因此, 应先

用Matrix $<\mathrm{LIB}>\mathrm{C}++$ 的库

//函数reshape()将一维矩阵 $m \_m a t B i t s$ 变为 $n$ Height $\times$ nWidthBytes的二维矩 阵， 再用rot90()函数

//将其逆时针旋转 $90^{\circ}$ ， 将矩阵变为 $n W i d t h B y t e s \times n H e i g h t$ 的二维矩阵

![](https://cdn.mathpix.com/cropped/2023_03_29_d26610fdae00bb73ec92g-13.jpg?height=89&width=1869&top_left_y=1301&top_left_x=204)

//若图像宽度与其字节宽度不同，则将由系统补齐的每行字节数为4的整 数倍的各列 0 删除, 以减 小矩阵大小加快处理速度 if(nWidthBytes $!=$ nWidth)

\{

m_matBits = m_matBits(c_p, colon $(1,1$, nWidth) $)$

\}

//将矩阵由unsigned char型转换为double型, 以便进行运算

$m \_m a t B i t s=$ mdouble(m_matBits); 

\subsection{3 将矩阵数据赋给图像数据区}

为使数据符合图像文件格式, 还应将处理后的矩阵数据赋 给图像数据区, 其代码如下:

$/ /$ 检查 $m \_m a t B i t s$ 矩阵是否为空

if(isempty(m_matBits) == 1)

\{

return FALSE;

\}

//将矩阵数据范围限定于 $0 \sim 255$ 之间

m_matBits = mabs(m_matBits);

Mm L = m_matBits > 255.0;

Mm NotL = !L;

m_matBits = times(m_matBits, NotL) + L * 255.0; //将矩阵由double型转换为unsigned char型, 以便将图像数据赋给矩阵 m_matBits $=$ muint8(m_matBits);

//计算nWidth/4的余数

int nTmp = (int)rem(nWidth, 4);

int nPadding;

//为矩阵各列补 0 , 以使其为符合 4 的整数倍

if(nTmp $>0)$

\{

nPadding $=4-$ nTmp;

m_matBits $=\mathrm{cat}\left(2, \mathrm{~m} \_\right.$matBits, repmat(muint8(0), (BR(size(m_matBits, 1)), nPadding)));

\}

//将矩阵顺时针旋转 $90^{\circ}$

m_matBits $=$ rot90(m_matBits, -1$)$;

//将图像数据赋绘矩阵

memcpy(pBits, m_matBits.addr(), (nWidthBytes * nHeight)*sizeof(unsigned char)); 

\subsection{4 利用矩阵运算进行图像变换}

\section{图像数据矩阵建立后, 便可利用 $M a t r i x<\mathrm{LIB}>\mathrm{C}++$ 的库函数}

\section{通过各种矩阵运算完成图像变换的工作。}

\section{1. 离散傅立叶变换}

Matrix $<\mathrm{LIB}>\mathrm{C}++$ 的库提供了函数 $\mathrm{dft}() 、 \mathrm{fft}()$ 和 $\mathrm{fft} 2()$ 分别用于 完成一维DFT、一维FFT和二维FFT运算，函数ifft()和ifft2()用于 完成一维FFT和二维FFT的逆傅立叶变换。在图像处理中常用的 函数是 $f f t 2()$ 和ifft2()，利用这两个函数便可分别完成图像的正、 反傅立叶变换。其核心代码如下： //调用Matrix $<\mathrm{Lib}>\mathrm{C}++$ 库函数fft2()完成二维离散傅立叶变换

$\mathrm{Mm} \mathrm{ff}=\mathrm{fft2}\left(\mathrm{m} \_\mathrm{matBits}\right) ;$

//调用Matrix $<\mathrm{Lib}>\mathrm{C}++$ 库函数fftshift()将频域中心移到矩阵中心

$\mathrm{ff}=\mathrm{fftshift(ff);}$

//调用Matrix $<\mathrm{Lib}>\mathrm{C}++$ 库函数mabs()计算频谱

m_matBits $=$ mabs(ff); 

\section{2. 离散余弦变换}

在 Matrix $<$ LIB $>$ C++库中并末提供离散余弦变换函数, 因此

需要编写相应的变换函数。由式 (7-61) 和式（7-63) 可知,

利用离散傅立叶正反变换便可完成离散余弦正反变换, 实际上

![](https://cdn.mathpix.com/cropped/2023_03_29_d26610fdae00bb73ec92g-19.jpg?height=105&width=2340&top_left_y=815&top_left_x=77)
如此完成离散余弦正反变换的。仔细阅读相应的.m文件便可得 出其实现变换的过程, 这样就可以编写用以完成一维DCT函数 $\operatorname{dct}()$ 的代码。完成一维离散余弦变换函数 $\operatorname{dct}()$ 后, 利用二维DCT 的可分离性, 便可方便的编制出用于二维离散余弦变换函数

![](https://cdn.mathpix.com/cropped/2023_03_29_d26610fdae00bb73ec92g-19.jpg?height=108&width=794&top_left_y=1569&top_left_x=75)


$\mathrm{b}=\operatorname{transpose}(\operatorname{dct}(\operatorname{transpose}(\operatorname{dct}(\arg 1))))$

其中, $\operatorname{arg1}$ 为待变换矩阵。

同理，可编制出一维IDCT函数变换 $\operatorname{idct}()$ 和二维IDCT函数 idct20)

与图像的离散傅立叶变换类似, 实现图像的离散余弦变换 的代码如下:

$\mathrm{Mm} \mathrm{ff}=\operatorname{dct} 2\left(\mathrm{~m} \_\right.$matBits $)$

//调用Matrix $<\mathrm{Lib}>\mathrm{C}++$ 库函数mabs()计算频谱

m_matBits $=\operatorname{mabs}(\mathrm{ff})$; 

\section{3. 离散沃尔什-哈达玛变换}

同样, 在Matrix $<$ LIB $>\mathrm{C}++$ 库中并末提供离散沃尔什-哈达玛 变换的函数, 但它提供了用于产生哈达玛矩阵的函数hadamard(), 其语法为

\section{$\mathrm{H}=$ hadamard $(\mathrm{N})$}

其中的元素为 1 或 -1 , 注意该矩阵只有当 $n$ 或 $n / 12$ 或 $n / 20$ 为 2 的 整次幂时才存在。

利用矩阵形式的WHT, 可由如下代码完成离散沃尔什-哈 达玛变换: //获得矩阵的行数和列数

Mm mSize = size(m_matBits)

//生成哈达玛矩阵

Mm HColum = hadamard $(\mathrm{mSize} . \mathrm{r}(1,1))$;

Mm HRow = hadamard $(\mathrm{mSize} \cdot \mathrm{r}(1,2))$;

//进行离散哈达玛变换

$\mathrm{Mm} \mathrm{ff}=\mathrm{HRow} * \mathrm{~m} \_$matBits $*$ HColum;

//调整系数以便以图像方式显示结果

$\mathrm{ff}=\mathrm{ff} * 1000 /(\mathrm{mSize} \cdot \mathrm{r}(1,1) * \mathrm{mSize} \cdot \mathrm{r}(1,2))$;

$/ /$ 调用Matrix $<\mathrm{Lib}>\mathrm{C}++$ 库函数mabs()计算频谱

m_matBits $=$ mabs(ff);