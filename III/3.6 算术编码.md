# 3.6 算术编码

​    算术编码有两种模式：一种是基于信源概率统计特性的固定编码模式，另一种是针对未知信源概率模型的自适应模式。自适应模式中各个符号的概率初始值都相同， 它们依据出现的符号而相应地改变。只要编码器和解码器都使用相同的初始值和相同的改变值的方法，那么它们的概率模型将保持一致。上述两种形式的算术编码均可用硬件实现，其中自适应模式适用于不进行概率统计的场合。有关实验数据表明，在未知信源概率分布的情况下， 算术编码一般要优于Huffman编码。在JPEG扩展系统中，就用算术编码取代了哈夫曼编码。

下面结合一个实例来阐述固定模式的算术编码的具体方法。 设一待编码的数据序列 (即信源) 为 “ dacab", 信源中各符号出现的概率依次为 $P(a)=0.4, P(b)=0.2, P(c)=0.2, \quad P(d)=0.2$ 。
首先, 数据序列中的各数据符号在区间 $[0,1]$ 内的间隔 (赋值范围)设定为 $a=[0,0.4), b=[0.4,0.6), c=[0.6,0.8)$ ， $d=[0.8,1.0)$
为便于讨论, 再给出一组关系式:
$$
\left\{\begin{array}{l}
\operatorname{Start}_{N}=\operatorname{Start}_{B}+\operatorname{Left}_{C} \times L \\
\operatorname{End}_{N}=\operatorname{Start}_{B}+\operatorname{Right}_{C} \times L
\end{array}\right.
$$
式中, $\operatorname{Start}_{\mathbb{N}} 、 End_{\mathbb{N}}$ 分别表示新间隔 (或称之为区间)的起始位置和结束位置, Start ${ }_{B}$ 表示前一间隔的起始位置, $L$ 为前一间隔的长度, Left $_C 、$ Right $_C$ 分别表示当前编码符号的初始区间的左端和右端。
第一个被压缩的符号为 “ $d$ "，其初始间隔为 $[0.8,1.0)$;
第二个被压缩的符号为 “ $a$ ", 由于前面的符号 “ $d^{\prime \prime}$ 的取值区间被限制在 $[0.8,1.0$ )范围内, 所以 “ $a$ ”的取值范围应在前一符号间隔 $[0.8,1.0)$ 的 $[0,0.4)$ 子区间内, 根据上式可知
$$
\begin{aligned}
& \text { Start }_{N}=0.8+0 \times(1.0-0.8)=0.8 \\
& \text { End }_{N}=0.8+0.4 \times(1.0-0.8)=0.88
\end{aligned}
$$
即 “ $a$ ”的实际编码区间在 $[0.8,0.88)$ 之间。

第三个被压缩的符号为 “ $c^{\prime \prime}$, 其编码取值范围应在 $[0.8$, $0.88)$ 区间的 $[0.6,0.8)$ 的子区间内, 据上式可知
$$
\begin{aligned}
& \text { Start }_N=0.8+0.6 \times(0.88-0.8)=0.848 \\
& \text { End }_N=0.8+0.8 \times(0.88-0.8)=0.864
\end{aligned}
$$
第四个被压缩的符号为 “ $a$ ”, 同理, 根据上式可知
$$
\begin{aligned}
& \operatorname{Start}_{N}=0.848+0 \times(0.864-0.848)=0.848 \\
& \operatorname{End}_{N}=0.848+0.4 \times(0.864-0.848)=0.8544
\end{aligned}
$$
第五个被压缩的符号为 “ $b$ ”, 同理, 根据上式可知
$$
\begin{aligned}
& \text { Start }_{N}=0.848+0.4 \times(0.8544-0.848)=0.84856 \\
& \text { End }_{N}=0.848+0.6 \times(0.8544-0.848)=0.85144
\end{aligned}
$$
至此, 数据序列 “dacab"已被描述为一个实数区间 $[0.85056$, $0.85184]$, 或者说在此区间内的任一实数值都惟一对应该数据序列。这样, 就可以用一个实数表示这一数据序列。我们把区间 [0. 850 56，0.851 84] 用二进制形式表示为 $[0.110110011011$, $0.110110100001]$ 。

从这个区间可以看出，0.1101101位于这个区间内并且其编码最短， 故把其作为数据序列“dacab”的编码输出。考虑到算术编码中任一数据序列的编码都含有“0.”，所以在编码时，可以不考虑“0.”，于是把1101101作为本例中的数据序列的算术编码。由此可见， 数据序列“dacab”用7比特的二进制代码就可以表示， 平均码长为1.4比特／字符。

​    解码是编码的逆过程，根据编码时的概率分配表和压缩后数据代码所在的范围，确定代码所对应的每一个数据符号。由此可见，算术编码的实现方法要比哈夫曼编码复杂一些。