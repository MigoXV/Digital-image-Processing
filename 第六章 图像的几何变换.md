[TOC]

# 第六章  图像的几何变换 

# 6.1 几何变换基础 



## 6.1.1 概述

图像的几何变换，是指使用户获得或设计的原始图像。按照需要产生大小、形状和位置的变化。从图像类型来分，图像的几何变换有二维平面图像的几何变换和三维图像的几何变换以及由三维向二维平面投影变换等。从变换的性质分， 图像的几何变换有平移、比例缩放、旋转、反射和错切等基本变换，透视变换等复合变换，以及插值运算等。 

 数字图像是把连续图像在坐标空间和性质空间离散化了的图像。例如，一幅二维数字图像就是把一幅连续的二维(2D)。图像在坐标空间XOY和性质空间F都离散化了的图像，它可以用一组二维(2D)数组f(x, y)来表示，其中x和y表示2D空间XOY中一个坐标点的位置，f代表图像在点(x, y)的某种性质F的数值，如果所处理的是一幅灰度图，这时f表示灰度值。而且此时f、x、y都在整数集合中取值。因此，除了插值运算外，常见的图像几何变换可以通过与之对应的矩阵线性变换来实现。 

对于2D图像几何变换及变换中心在坐标原点的比例缩放、 反射、 错切和旋转等各种变换，都可以用2×2的矩阵表示和实现。但是一个2×2变换矩阵$T=\left[\begin{array}{ll}a & b \\ c & d\end{array}\right]$却不能实现图像的平移以及绕任意点的比例缩放、反射、错切和旋转等各种变换。因此，为了能够用统一的矩阵线性变换形式，表示和实现这些常见的图像几何变换，就需要引入一种新的坐标，即齐次坐标。利用齐次坐标来变换处理，才能实现上述各种2D图像的几何变换。 

## 6.1.2 齐次坐标

现设点 $P_0\left(x_0, y_0\right)$ 进行平移后, 移到 $P(x, y)$, 其中 $x$ 方向的平移量为 $\Delta x, y$ 方向的平移量为 $\Delta y$ 。那么, 点 $P(x, y)$ 的坐标为
$$
\left\{\begin{array}{l}
x=x_0+\Delta x \\
y=y_0+\Delta y
\end{array}\right.
$$
如图6-1所示。这个变换用矩阵的形式可以表示为
$$
\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\begin{array}{ll}
1 & 0 \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
x_0 \\
y_0
\end{array}\right]+\left[\begin{array}{l}
\Delta x \\
\Delta y
\end{array}\right]
$$
图6-1 点的平移(不再是笛卡尔坐标系)

而平面上点的变换矩阵$T=\left[\begin{array}{ll}a & b \\ c & d\end{array}\right]$中没有引入平移常量，无论$a、b、c、d$取什么值，都不能实现上述的平移变换。因此，需要使用$2\times3$阶变换矩阵，取其形式为 
$$
T=\left[\begin{array}{ccc}
1 & 0 & \Delta x \\
0 & 1 & \Delta y
\end{array}\right]
$$
此矩阵的第一、二列构成单位矩阵，第三列元素为平移常量。由上述可知，对2D图像进行变换，只需要将图像的点集矩阵乘以变换矩阵即可，2D图像对应的点集矩阵是2×*n*阶的，而上式扩展后的变换矩阵是2×3阶的矩阵，这不符合矩阵相乘时要求前者的列数与后者的行数相等的规则。

所以需要在点的坐标列矩阵 $\left[\begin{array}{ll}x & y\end{array}\right]^{T}$ 中引入第三个元素, 增加一个附加坐标, 扩展为 $3 \times 1$ 的列矩阵 $\left[\begin{array}{lll}x & y & 1\end{array}\right]^{T}$, 这样用三维空间点 $(x, y, 1)$ 表示二维空间点 $(x, y)$, 即采用一种特殊的坐标，可以实现平移变换，变换结果为
$$
P=T \cdot P_0=\left[\begin{array}{ccc}1 & 0 & \Delta x \\ 0 & 1 & \Delta y\end{array}\right]\left[\begin{array}{l}x_0 \\ y_0 \\ 1\end{array}\right]=\left[\begin{array}{l}x_0+\Delta x \\ y_0+\Delta y\end{array}\right]=\left[\begin{array}{l}x \\ y\end{array}\right]
$$

式 $\left\{\begin{array}{l}x=x_0+\Delta x \\ y=y_0+\Delta y\end{array}\right.$ 符合上述平移后的坐标位置。通常将 $2 \times 3$ 阶矩阵扩
充为 $3 \times 3$ 阶矩阵, 以拓宽功能。由此可得平移变换矩阵为
$$
T=\left[\begin{array}{lll}
1 & 0 & \Delta x \\
0 & 1 & \Delta y
\end{array}\right] \text { a- }
$$
下面再验证一下点 $P(x, y)$ 按照 $3 \times 3$ 的变换矩阵 $T$ 平移变换的结果
$$
P=T \cdot P_0=\left[\begin{array}{lll}
1 & 0 & \Delta x \\
0 & 1 & \Delta y \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_0 \\
y_0 \\
1
\end{array}\right]=\left[\begin{array}{l}
x_0+\Delta x \\
y_0+\Delta y \\
1
\end{array}\right]=\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]
$$
从上式可以看出, 引入附加坐标后, 扩充了矩阵的第 3 行, 并没有使变换结果受到影响。这种用 $n+1$ 维向量表示 $n$ 维向量的方法称为齐次坐标表示法。

因此, 2D图像中的点坐标 $(x, y)$ 通常表示成齐次坐标 $(H x, H y$, H), 其中 $H$ 表示非零的任意实数, 当 $H=1$ 时, 则 $(x, y, 1)$ 就称为点 $(x, y)$ 的规范化齐次坐标。显然规范化齐次坐标的前两个数是相应二维点的坐标, 没有变化, 仅在原坐标中增加了 $H=1$ 的附加坐标。
由点的齐次坐标 $(H x, H y, H)$ 求点的规范化齐次坐标 $(x, y,1)$, 可按如下公式进行:
$$
x=\frac{H x}{H} \quad y=\frac{H y}{H}
$$

齐次坐标的几何意义相当于点 $(x, y)$ 落在 $3 D$ 空间 $H=1$ 的平面上, 如图6-2所示。如果将XOY 平面内的三角形 $abc$ 的各顶点表示成齐次坐标 $\left(x_i, y_i, 1\right)(i=1,2,3)$ 的形式, 就变成 $H=1$ 平面内的三角形 $a_1 b_1 c_1$ 的各顶点。

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328144044825.png" alt="image-20230328144044825" style="zoom:50%;" />

图6-2 齐次坐标的几何意义

齐次坐标在2D图像几何变换中的另一个应用是：如某点S(60 000， 40 000)在16位计算机上表示则大于32 767的最大坐标值， 需要进行复杂的操作。但如果把S的坐标形式变成(Hx, Hy, H) 形式的齐次坐标，则情况就不同了。在齐次坐标系中，设H＝1 ／2，则 (60 000，40 000)的齐次坐标为(1/2x, 1/2y, 1/2)，那么所要表示的点变为(30 000, 20 000, 1/2)，此点显然在16位计算机上二进制数所能表示的范围之内。 

因此，采用齐次坐标，并将变换矩阵改成3×3阶的形式后， 便可实现所有2D图像几何变换的基本变换。

## 6.1.3 二维图像几何变换的矩阵



利用齐次坐标及改成 $3 \times 3$ 阶形式的变换矩阵, 实现 $2 D$ 图像几何变换的基本变换的一般过程是: 将 $2 \times n$ 阶的二维点集矩阵 $\left[\begin{array}{c}x_{0 i} \\ y_{0 i}\end{array}\right]_{2 \times n}$ 矩阵龶示成齐次完成, 坐标 $\left[\begin{array}{l}x_{0 i} \\ y_{0 i} \\ 1\end{array}\right]_{3 \times n}$ 的形式, 然后乘以相应的变换
变换后的点集矩阵=变换矩阵 $T \times$ 变换前的点集矩阵
(图像上各点的新齐次坐标)      (图像上各点的原齐次坐标)

设变换矩阵T为
$$
T=\left[\begin{array}{lll}
a & b & p \\
c & d & q \\
l & m & s
\end{array}\right]
$$
则上述变换可以用公式表示为
$$
\left[\begin{array}{cccc}
H x_1^{\prime} & H x_2^{\prime} & \Lambda & H x_n^{\prime} \\
H y_1^{\prime} & H y_2^{\prime} & \Lambda & H y_n^{\prime} \\
H & H & \Lambda & H
\end{array}\right]_{3 \times n}=T \times\left[\begin{array}{llll}
x_1 & x_2 & \Lambda & x_n \\
y_1 & y_2 & \Lambda & y_n \\
1 & 1 & \Lambda & 1
\end{array}\right]_{3 \times n}
$$
图像上各点的新齐次坐标规范化后的点集矩阵为
$$
\left[\begin{array}{rrrr}
x_1^{\prime} & x_2^{\prime} & \Lambda & x_n^{\prime} \\
y_1^{\prime} & y_2^{\prime} & \Lambda & y_n^{\prime} \\
1 & 1 & \Lambda & 1
\end{array}\right]_{3 \times n}
$$
引入齐次坐标后，表示2D图像几何变换的3×3矩阵的功能就完善了，可以用它完成2D图像的各种几何变换。下面讨论 3×3阶变换矩阵中各元素在变换中的功能。几何变换的3×3矩阵的一般形式为
$$
T=\left[\begin{array}{lll}
a & b & p \\
c & d & q \\
l & m & s
\end{array}\right]
$$
3×3的阶矩阵T可以分成四个子矩阵。其中，$\left[\begin{array}{ll}a & b \\ c & d\end{array}\right]_{2 \times 2}$这一子矩阵可使图像实现恒等、 比例、 反射(或镜像)、 错切和旋转变换。［l m］这一行矩阵可以使图像实现平移变换。［p q］ T这一列矩阵可以使图像实现透视变换，但当p=0，q=0时它无透视作用。［s］这一元素可以使图像实现全比例变换。例如， 将图像进行全比例变换， 即
$$
\left[\begin{array}{lll}1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & s\end{array}\right] \times\left[\begin{array}{c}x_{0 i} \\ y_{0 i} \\ 1\end{array}\right]=\left[\begin{array}{c}x_i \\ y_i \\ s\end{array}\right]
$$

将齐次坐标$[x_i \quad y_i \quad s]^T$规范化后，$[\dfrac{x_{oi}}{s} \quad \dfrac{y_{oi}}{s} \quad s]^T=[x_i \quad y_i \quad 1]^T$。 由此可见 

当 $s>1$ 时, 图像按比例缩小; 当 $0<s<1$ 时, 整个图像按比例放大; 当 $s=1$ 时，图像大小不变。

# 6.2 图像比例缩放

## 6.2.1 图像比例缩放变换

图像比例缩放是指将给定的图像在x轴方向按比例缩放 $f x$ 倍, 在 $y$ 轴方向按比例缩放 $f y$ 倍, 从而获得一幅新的图像。如果 $f x=f y$, 即在 $x$ 轴方向和 $y$ 轴方向缩放的比率相同, 称这样的比例缩放为图像的全比例缩放。如果 $f x \neq f y$, 图像的比例缩放会改变原始图像的像素间的相对位置, 产生几何畸变。设原图像中的点 $P_0\left(x_0, y_0\right)$ 比例缩放后, 在新图像中的对应点为 $P(x, y)$, 则 $P_0\left(x_0, y_0\right)$ 和 $P(x, y)$ 之间的对应关系如图6-3所示。

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150211842.png" alt="image-20230328150211842" style="zoom:50%;" />

图6-3 比例缩放

比例缩放前后两点 $P_0\left(x_0, y_0\right) 、 P(x, y)$ 之间的关系用矩阵形式可以表示为
$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{lll}
f x & 0 & 0 \\
0 & f x & 0 \\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{l}
x_0 \\
y_0 \\
1
\end{array}\right]\tag{6-1}
$$
公式 (6-1) 的逆运算为
$$
\left[\begin{array}{l}
x_0 \\
y_0 \\
1
\end{array}\right]=\left[\begin{array}{lll}
\frac{1}{f x} & 0 & 0 \\
0 & \frac{1}{f x} & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_0 \\
y_0 \\
1
\end{array}\right]
$$
即
$$
\left\{\begin{array}{l}
x_0=\frac{x}{f x} \\
y_0=\frac{y}{f y}
\end{array}\right.
$$
比例缩放所产生的图像中的像素可能在原图像中找不到相应的像素点，这样就必须进行插值处理。插值处理常用的方法有两种， 一种是直接赋值为和它最相近的像素值， 另一种是通过一些插值算法来计算相应的像素值。前一种方法计算简单， 但会出现马赛克现象；后者处理效果要好些，但是运算量也相应增加。 在下面的算法中直接采用了前一种做法。实际上，这也是一种插值算法， 称为最邻近插值法(Nearest Neighbor Interpolation)

下面首先讨论图像的比例缩小。最简单的比例缩小是当 fx=fy=1／2时，图像被缩到一半大小，此时缩小后图像中的(0， 0)像素对应于原图像中的(0， 0)像素； (0， 1)像素对应于原图像中的(0， 2)像素； (1， 0)像素对应于原图像中的(2， 0)像素， 依此类推。图像缩小之后，因为承载的信息量小了，所以画布可相应缩小。此时， 只需在原图像基础上，每行隔一个像素取一点，每隔一行进行操作，即取原图的偶(奇)数行和偶(奇)数列构成新的图像，如图6-4所示。如果图像按任意比例缩小， 则需要计算选择的行和列

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150350082.png" alt="image-20230328150350082" style="zoom:50%;" />

如果$M×N$大小的原图像$F(x，y)$缩小为 $kM×kN$大小$(k<1)$ 的新图像$I(x，y)$时，则
$$
I(x, y)=F(\operatorname{int}(c \times x), \operatorname{int}(c \times y))
$$
其中， $c=1／k$。由此公式可以构造出新图像，如图6-5所示。

![image-20230328150453396](https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150453396.png)

图6-5 图像按任意比例缩小

当 $f x \neq f y(f x, f y>0)$ 时, 图像不按比例缩小, 这种操作因为在 $x$ 方向和y方向的缩小比例不同, 一定会带来图像的几何畸变。图像不按比例缩小的方法是： 如果 $M \times N$ 大小的旧图 $F(x, y)$ 缩小为 $k_1 M \times k_2 N\left(k_1<1, k_2<1\right)$ 大小的新图像 $I(x, y)$ 时, 则
$$
I(x, y)=F\left(\operatorname{int}\left(c_1 \times x\right), \operatorname{int}\left(c_2 \times y\right)\right)
$$
其中
$$
c=\frac{1}{k_1}, c_2=\frac{1}{k_2}
$$
由此公式可以构造出新图像。

图像在缩小操作中, 是在现有的信息里如何挑选所需要的有用信息。而在图像的放大操作中, 则需要对尺寸放大后所多出来的空格填入适当的像素值, 这是信息的估计问题, 所以较图像的缩小要难一些。当 $f x=f y=2$ 时, 图像被按全比例放大 2 倍, 放大后图像中的 $(0,0)$ 像素对应于原图中的 $(0,0)$ 像素; $(0,1)$ 像素对应于原图中的 $(0,0.5)$ 像素, 该像素不存在, 可以近似为 $(0,0)$ 也可以近似 $(0,1) ; \quad(0,2)$ 像素对应于原图像中的 $(0,1)$ 像素; $(1,0)$ 像素对应于原图中的 $(0.5,0)$, 它的像素值近似于 $(0,0)$ 或 $(1,0)$ 像素; (2,0)像素对应于原图中的 $(1,0)$ 像素, 依此类推。其实这是将原图像每行中的像素重复取值一遍, 然后每行重复一次。图66是原始图像, 图6-7和图6-8是分别采用上述两种近似方法放大后的图像。

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150656606.png" alt="image-20230328150656606" style="zoom: 67%;" />

图6-6 放大前的图像

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150707714.png" alt="image-20230328150707714" style="zoom: 67%;" />

图6-7 按最近邻域法放大两倍的图像

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150716930.png" alt="image-20230328150716930" style="zoom:67%;" />

图6-8 按插值法放大两倍的图像

一般地, 按比例将原图像放大 $k$ 倍时, 如果按照最近邻域法则需要将一个像素值添在新图像的 $k \times k$ 的子块中, 如图6-9所示。 显然, 如果放大倍数太大, 按照这种方法处理会出现马赛克效应。当 $f x \neq f y(f x, f y>0)$ 时, 图像在 $x$ 方向和 $y$ 方向不按比例放大, 此时, 这种操作由于 $x$ 方向和 $y$ 方向的放大倍数不同, 一定带来图像的几何畸变。放大的方法是将原图像的一个像素添到新图像的一个 $k_1 \times k_2$ 的子块中去。为了提高几何变换后的图像质量, 常采用线性揷值法。该方法的原理是, 当求出的分数地址与像素点不一致时, 求出周围四个像素点的距离比, 根据该比率, 由四个邻域的像素灰度值进行线性揷值, 如图6-10所示。

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150808789.png" alt="image-20230328150808789" style="zoom:50%;" />

图6-9 按最近邻域法放大五倍的图像

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328150816370.png" alt="image-20230328150816370" style="zoom:50%;" />

图6-10 线性插值法示意图

简化后的灰度值计算式如下:
$$
\begin{aligned}
& g(x, y)=(1-q)\{(1-p) \times g([x],[y])+p \times g([x] \\
& +1,[y])\}+q\{(1-p) \times g([x],[y]+1)+p \times g([x] \\
& +1,[y]+1)\}
\end{aligned}
$$
式中: $g(x, y)$ 为坐标 $(x, y)$ 处的灰度值, $[x]$ 、 $[y]$ 分别为不大于 $x, y$ 的整数。关于这个问题的详细算法及其实现, 读者可以参考有关参考文献。

## 6.2.2 比例缩放的实现 

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328151005743.png" alt="image-20230328151005743" style="zoom:50%;" />

图6-11 图像比例缩放处理结果

下面给出这个函数的框架和主要算法。

```c
//*****************************************
//函数名称： BOOL ZoomImage()
//基本功能： 本函数对传入的CDibObject对象中的图像进行缩放操作
//参数说明： float fXZoomRatio    X轴方向缩放比率
//	         float fYZoomRatio    Y轴方向缩放比率
//	         BOOL bBilinear        TRUE为双线性插值， FALSE为最邻近插值
//	         CDibObject *pDibObject     默认为NULL
//返回值： BOOL  成功返回TRUE， 失败返回FALSE 
//*****************************************
BOOL CGeoTrans::  ZoomImage(float fXZoomRatio,  float fYZoomRatio, 
			BOOL bBilinear,  CDibObject *pDibObject)
{
  //获得图像宽度和高度， 计算缩放后的图像实际宽度
  nNewWidth = (int)(nOldWidth * fXZoomRatio + 0.5);
  nNewHeight = (int)(nOldHeight * fYZoomRatio + 0.5);
  //获取源图像指针，为新图像分配内存，用白色填充新图像数据区，调整新图像信息
  //由图像位数确定的移动字节数nMovedBits
  //针对图像每行进行操作
  for(y = 0; y < nNewHeight; y++)
  {
    //指向新图像第y行
    pNewTemp = pNewBits;
    pNewTemp += (nNewHeight -1[KG*3]-y) * nNewWidthBytes;
    //针对图像每列进行操作
    for(x = 0; x < nNewWidth; x++)
    {
      //计算该像素在源图像中的坐标
      int y0 = (long) (y／fYZoomRatio +0.5);
      int x0 = (long) (x／fXZoomRatio +0.5);
      //判断是否在源图范围内
      if( (x0 >= 0) && (x0 < nOldWidth) && (y0 >= 0) && (y0 < nOldHeight))
      {
        if(bBilinear)
        { 
                  //双线性插值
         }
        else
        {
          //指向源图像第y0行， 第x0个像素
          pOldTemp = pOldBits;
          pOldTemp += (nOldHeight - 1 - y0) * nOldWidthBytes;
          pOldTemp += x0 * nMovedBits;
          memcpy(pNewTemp,  pOldTemp,  nMovedBits);
           }
        }
        pNewTemp += nMovedBits;
     }
  }
  //将内存解锁和将不再使用的内存释放， 将新图像设置为当前图像
  return TRUE;
} 

```



# 6.3 图像平移 

## 6.3.1 图像平移变换 

![image-20230328151524099](https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328151524099.png)

图6-12 图像平移

设点 $P_{0}\left(x_{0}, y_{0}\right)$ 进行平移后, 移到 $P(x, y)$, 其中 $x$ 方向的平移量为 $\Delta x, y$ 方向的平移量为 $\Delta y$ 。那么，点 $P(x, y)$ 的坐标为

$$
\left\{\begin{array}{l}
x=x_{0}+\Delta x \\
y=y_{0}+\Delta y
\end{array}\right.
$$

利用齐次坐标, 变换前后图像上的点 $P_{0}\left(x_{0}, y_{0}\right)$ 和 $P(x, y)$ 之间的关系可以用如下的矩阵变换表示为

$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{lll}
1 & 0 & \Delta x \\
0 & 1 & \Delta y \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_0 \\
y_0 \\
1
\end{array}\right]\tag{6-2}
$$
对变换矩阵求逆, 可以得到式 (6-2) 的逆变换
$$
\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]=\left[\begin{array}{ccc}
1 & 0 & -\Delta x \\
0 & 1 & -\Delta y \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]
$$

即

$$
\left\{\begin{array}{l}
x_{0}=x-\Delta x \\
y_{0}=y-\Delta y
\end{array}\right.
$$

这样, 平移后的图像上的每一点都可以在原图像中找到对应的点。例如, 对于新图中的 $(0,0)$ 像素, 代入上面的方程组,可以求出对应原图中的像素 $(-\Delta x,-\Delta y)$ 。如果 $\Delta x$ 或 $\Delta y 大于 0$, 则点 $(-\Delta x,-\Delta y)$ 不在原图像中。对于不在原图像中的点, 可以直接将它的像素值统一设置为 0 或者255 (对于灰度图就是黑色或白色)。同样, 若有像素点不在原图像中, 也就说明原图像中有点被移出显示区域。如果不想丢失被移出的部分图像, 可以将新生成的图像宽度扩大 $|\Delta x|$, 高度扩大 $|\Delta y|$ 。

<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-04.jpg?height=1094&width=1161&top_left_y=276&top_left_x=657" style="zoom: 25%;" />

图6-13 平移前的图像



<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-05.jpg?height=900&width=972&top_left_y=427&top_left_x=866" style="zoom:25%;" />

图6-14 平移后的图像

<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-06.jpg?height=851&width=908&top_left_y=493&top_left_x=831" style="zoom:25%;" />

图6-15 平移扩大后的图像



## 6.3.2 图像平移的算法

按照上述理论, 可以比较容易地用 VC++来实现图像的平移。 下面介绍灰度图像的平移, 因为灰度图像每个像素位数正好是 8 位, 即 1 个字节, 在进行图像处理时可以不用考虑拼凑字节的问题。而且由于灰度图像调色板的特殊性, 进行灰度图像处理时不必考虑调色板的问题。所以, 在介绍图像处理时,一般采用灰度图像, 以便将重点放在算法本身。由上述分析, 可以得到实现图像平移的算法如下。 

```c++
//*****************************************
//函数名称： BOOL TranslationPixel() 
//基本功能： 本函数对传入的CDibObject对象中的图像进行逐点平移操作
//参数说明： long  lXOffset  	X轴平移量(像素数)
//	         long  lYOffset	Y轴平移量(像素数)
//返回值： BOOL  成功返回TRUE， 失败返回FALSE
//注意： 该函数不会改变图像的大小， 移出的部分图像将截去， 空白部分用白色填充
//*****************************************
BOOL CGeoTrans:: TranslationPixel(long lXOffset,  long lYOffset,  CDibObject *pDibObject) 
{
  //定义变量， 获得源图像指针及其图像信息， 为新图像分配内存及用白色填充新图 
   //由图像位数确定的移动字节数nMovedBits， 对于灰度图像有nMovedBits = 1
  //每行
  for(y = 0; y < nHeight; y++)
  {
    pNewTemp = pNewBits;
    pNewTemp +=  (nHeight -1-y) * nWidthBytes;
    //每列
    for(x = 0; x < nWidth; x++)
    {
      //指向新DIB第y行， 第x个像素的指针， 计算该像素在源DIB中的坐标
      int x0 = x – lXOffset;
      int y0 = y – lYOffset;
      //判断是否在源图范围内
      if( (x0 >= 0) && (x0 < nWidth) && (y0 >= 0) && (y0 < nHeight)) 
{
//指向源DIB第y0行， 第x0个像素的指针
pOldTemp = pOldBits;
pOldTemp += (nHeight -1-y0) * nWidthBytes;
pOldTemp += x0 * nMovedBits;
//复制像素
memcpy( pNewTemp, pOldTemp, nMovedBits );
}
pNewTemp += nMovedBits;
}
}
//用新图像数据填充源图像数据区
memcpy( pOldBits, pNewBits, nWidthBytes * nHeight );
}
```

# 图像镜像

## 6.4.1 图像镜像变换

图像的镜像变换不改变图像的形状。图像的镜像(Mirror)变换分为两种：一种是水平镜像，另外一种是垂直镜像。图像的水平镜像操作是将图像左半部分和右半部分以图像垂直中轴线为中心进行镜像对换；图像的垂直镜像操作是将图像上半部分和下半部分以图像水平中轴线为中心进行镜像对换，如图6-16所示

![image-20230328152249588](https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328152249588.png)

图6-16 图像的镜像

图像的镜像变换也可以用矩阵变换表示。设点 $P_{0}\left(x_{0}, y_{0}\right)$ 进行镜像后的对应点为$P(x, y)$, 图像高度为 fHeight, 宽度为fWidth,原图像中 $P_0\left(x_0, y_0\right)$ 经过水平镜像后坐标将变为 (fWidth- $\left.x_0, y_0\right)$,其矩阵表达式为
$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{rrc}
-1 & 0 &  fWidth  \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]\tag{6-3}
$$

逆运算矩阵表达式为

$$
\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]=\left[\begin{array}{ccc}
-1 & 0 &  fwidth  \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]
$$

即

$$
\left\{\begin{array}{l}
x_{0}=f \text { Width }-x \\
y_{0}=y
\end{array}\right.
$$

同样, $P_{0}\left(x_{0}, y_{0}\right)$ 经过垂直镜像后坐标将变为 $\left(x_{0}, f H e i g h t-y_{0}\right)$,

其矩阵表表达式为

$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{ccc}
1 & 0 & 0 \\
0 & -1 & fHeight  \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]
\tag{6-4}
$$

逆运算矩阵表达式为

$$
\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]=\left[\begin{array}{ccc}
1 & 0 & 0 \\
0 & -1 & \text { fHeight } \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]
$$

即

$$
\left\{\begin{array}{l}
x_{0}=x \\
y_{0}=f W i d t h-y
\end{array}\right.
$$

## 6.4.2 图像镜像的算法

按照上面的变换公式 (6-3) 和(6-4)，可以比较简单的实现图像的水平和垂直镜像操作, 读者可以参照6.3.2中平移的算法, 写出公式 (6-3) 和 (6-4) 对应的算法。

和图像平移一样, 在垂直镜像中也可以利用位图存储的连续性整行复制图像。下面将介绍采用这种方法的算法, 其主要算法如下, bDirection为真时表示水平镜像, 否则为垂直镜像。

```c++
 //由图像位数确定的移动字节数nMovedBits
  //判断镜像方式
  if (bDirection)
  {
    //垂直中轴坐标
    int nMiddleX = nWidth / 2;
    //针对图像每行进行操作
    for(y = 0; y < nHeight; y++)
    {
      //指向图像的倒数第y行
      pOldTemp = pOldBits;
      pOldTemp +=  y * nWidthBytes;
      pNewTemp = pNewBits; 
      pNewTemp +=  y * nWidthBytes;
      //针对每行图像左半部分进行操作
      for(x = 0; x <= nMiddleX; x++)
      {
        //将源图像第x个像素复制到新图像倒数第x个像素
        pTemp1 = pOldTemp + x * nMovedBits;
        pTemp2 = pNewTemp + (nWidth -1 - x) * nMovedBits;
        memcpy(pTemp2,  pTemp1,  nMovedBits);
        //将源图像倒数第x个像素复制到新图像第x个像素
        pTemp1 = pOldTemp + (nWidth -1 - x) * nMovedBits;
        pTemp2 = pNewTemp + x * nMovedBits;
        memcpy(pTemp2,  pTemp1,  nMovedBits);
  }
      }
  } 
else
  {
    //水平中轴坐标
    int nMiddleY = nHeight / 2;
    //针对上半图像进行操作
    for(y = 0; y <= nMiddleY; y++)
    {
      //指向源图像倒数第y行像素起点的指针
      pOldTemp = pOldBits;
      pOldTemp +=  y * nWidthBytes;
      //指向新图像第y行像素起点的指针
      pNewTemp = pNewBits;
      pNewTemp +=  (nHeight - 1 - y) * nWidthBytes;
      //将源图像倒数第y行像素复制到新图像第y行 
      memcpy(pNewTemp,  pOldTemp,  nWidthBytes);
      //指向源图像第y行像素起点的指针
      pOldTemp = pOldBits;
      pOldTemp +=  (nHeight -1 -y) * nWidthBytes;
      //指向新图像倒数第y行像素起点的指针
      pNewTemp = pNewBits;
      pNewTemp +=  y * nWidthBytes;
      //将源图像第y行像素复制到新图像倒数第y行
      memcpy(pNewTemp,  pOldTemp,  nWidthBytes);
 }
  }
  //用新图像数据填充原图像数据区
  memcpy( pOldBits,  pNewBits,  nWidthBytes * nHeight ); 

```



<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-22.jpg?height=858&width=938&top_left_y=413&top_left_x=730" style="zoom: 25%;" />

图6-17 镜像前的图像

<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-23.jpg?height=982&width=1183&top_left_y=338&top_left_x=652" style="zoom:25%;" />

图6-18 水平镜像

<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-24.jpg?height=954&width=1033&top_left_y=365&top_left_x=679" style="zoom:25%;" />

图6-19 垂直镜像

# 6.5 图像旋转

## 6.5.1 图像旋转变换

本节介绍一种相对复杂的几何变换一图像的旋转。一般图像的旋转是以图像的中心为原点, 将图像上的所有像素都旋转 一个相同的角度。图像的旋转变换是图像的位置变换, 但旋转后, 图像的大小一般会改变。和图像平移一样, 在图像旋转变 换中既可以把转出显示区域的图像截去, 也可以扩大图像范围 以显示所有的图像。如图6-20、图6-21所示。

<img src="https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-26.jpg?height=599&width=947&top_left_y=587&top_left_x=713" style="zoom: 33%;" />

图6-20 旋转前的图像 
![](https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-27.jpg?height=838&width=2098&top_left_y=432&top_left_x=169)

图6-21 旋转 $\theta$ 后的图像(扩大图像、转出部分被截)

同样, 图像的旋转变换也可以用矩阵变换表示。设点 $P_{0}\left(x_{0}, y_{0}\right)$旋转 $\theta$ 角后的对应点为 $P(x, y)$, 如图6-22所示。那么, 旋转前后 点 $P_{0}\left(x_{0}, y_{0}\right) 、 P(x, y)$ 的坐标分别是:

![](https://cdn.mathpix.com/cropped/2023_03_28_09ce99927b2515b3c70fg-28.jpg?height=944&width=1209&top_left_y=548&top_left_x=607)
图6-22 图像旋转 $\theta$ 角
$$
\begin{aligned}
& \left\{\begin{array}{l}
x_0=r \cos \alpha \\
y_0=r \sin \alpha
\end{array}\right. \\
& \left\{\begin{array}{l}
x=r \cos (\alpha-\theta)=r \cos \alpha \cos \theta+r \sin \alpha \sin \theta=x_0 \cos \theta+y_0 \sin \theta \\
y=r \sin (\alpha-\theta)=r \sin \alpha \cos \theta-r \cos \alpha \sin \theta=-x_0 \sin \theta+y_0 \cos \theta
\end{array}\right.
\end{aligned}
$$
写成矩阵表达式为
$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{ccc}
\cos \theta & \sin \theta & 0 \\
-\sin \theta & \cos \theta & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_0 \\
y_0 \\
1
\end{array}\right]\tag{6-5}
$$
其逆运算为

$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{ccc}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]
$$

利用公式 (6-5) 可以确定旋转后图像上的像素。例如, 当 $\theta=30^{\circ}$ 时, 公式 (6-5) 为

$$
\left\{\begin{array}{l}
x=0.866 x-0.5 y \\
y=0.5 x+0.866
\end{array}\right.
$$
而且, 此时

$$
\begin{aligned}
& x_{\min }=0.866-0.5 \times 3=-0.634 ; x_{\min }=0.866 \times 3-0.5=2.098 \\
& y_{\min }=0.866+0.5=1.366 ; \quad y_{\max }=0.866 \times 3+0.5 \times 3=4.098
\end{aligned}
$$
![](https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-01.jpg?height=622&width=1950&top_left_y=773&top_left_x=346)
图6-23 图像旋转 $\theta$ 角

利用公式(6-5)进行图像旋转时需要注意如下两点:

(1) 图像旋转之前, 为了避免信息的丢失, 一定要有坐标平移，具体的做法有如图6-24所示的两种方法。
![](https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-02.jpg?height=870&width=1744&top_left_y=674&top_left_x=378)

图6-24 图像旋转之前进行的平移 (2) 图像旋转之后, 会出现许多空洞点, 如图6-23所示。对 这些空洞点必须进行填充处理, 否则画面效果不好, 一般也称 这种操作为揷值处理。最简单的方法是行揷值方法或列揷值方 法:

(1) 找出当前行的最小和最大的非白点的坐标, 记作: $(i, k 1)$ 、 $(i, k 2)$ 。

(2) 在(k1, k2)范围内进行揷值, 揷值的方法是: 空点的像素 值等于前一点的像素值。

(3) 同样的操作重复到所有行。经过如上的揷值处理之后, 图像效果就变得自然。如图6-25所示。列揷值方法与此类同, 请读者自己给出。 
![](https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-04.jpg?height=650&width=1970&top_left_y=539&top_left_x=228)

图6-25 图6-23中的图像处理后的效果

## 6.5.2 图像旋转的实现

按照上述理论，也可以用VC++编程实现图像的旋转。为了 将重点放在算法本身, 下面介绍灰度图像的旋转算法。由上面 的公式(6-6)以及产生空穴时的双线性揷值方法，可以编制一 个实现图像旋转的函数RotateDIB2()。下面给出这个函数的框架和主要算法。

```c++
//*****************************************
//函数名称： BOOL Rotate()  
//基本功能： 本函数对传入的CDibObject对象中的图像进行旋转操作
//参数说明： int iRotateAngle   旋转的角度(0～360度)
//  	        BOOL bBilinear    TRUE为双线性插值， FALSE为最邻近插值
//	        CDibObject *pDibObject    默认为NULL 
//返回值： BOOL  成功返回TRUE， 失败返回FALSE
//*****************************************
BOOL CGeoTrans:: Rotate(int nRotateAngle, BOOL bBilinear, CDibObject *pDibObject)
{
  //获得图像宽度和高度: nOldWidth、 nOldHeight
  //定义旋转角度(弧度)及其正弦和余弦值: fRotateAngle、 fSina、 fCosa
  //定义源图四个角的坐标、 旋转后四个角的坐标(以图像中心为坐标系原点)
  //计算旋转角度的正弦和余弦值
  //计算源图的四个角的坐标(以图像中心为坐标系原点)
  //计算新图四个角的坐标(以图像中心为坐标系原点) 
  fDstX1 =  fCosa * fSrcX1 + fSina * fSrcY1;
  fDstY1 = -fSina * fSrcX1 + fCosa * fSrcY1;
  fDstX2 =  fCosa * fSrcX2 + fSina * fSrcY2;
  fDstY2 = -fSina * fSrcX2 + fCosa * fSrcY2;
  fDstX3 =  fCosa * fSrcX3 + fSina * fSrcY3;
  fDstY3 = -fSina * fSrcX3 + fCosa * fSrcY3;
  fDstX4 =  fCosa * fSrcX4 + fSina * fSrcY4;
  fDstY4 = -fSina * fSrcX4 + fCosa * fSrcY4;
  //计算旋转后的图像实际宽度
  int nNewWidth=(long)(max(fabs(fDstX4-fDstX1), fabs(fDstX3-fDstX2))+0.5);
  //计算旋转后的图像高度 
int nNewHeight=(long)(max(fabs(fDstY4-fDstY1), fabs(fDstY3-fDstY2))+0.5);
  //计算两个常数
 f1= (float) (-0.5 * (nNewWidth - 1) * fCosa - 0.5 * (nNewHeight - 1) * fSina
        + 0.5 * (nOldWidth  - 1));
 f2= (float) ( 0.5 * (nNewWidth - 1) * fSina - 0.5 * (nNewHeight - 1) * fCosa
        + 0.5 * (nOldHeight - 1)); 
  //获取指向源图像的指针， 为旋转图像分配内存并用白色填充新图像数据区
  //由图像位数确定的移动字节数nMovedBits
  //针对图像每行进行操作
  for(y = 0; y < nNewHeight; y++)
  { 
   //指向新图像第y行
    pNewTemp = pNewBits;
    pNewTemp += (nNewHeight - 1 - y) * nNewWidthBytes;
    //针对图像每列进行操作
    for(x = 0; x < nNewWidth; x++)
    {
      //计算该像素在源图像中的坐标
      int y0 = (long) (-((float) x) * fSina + ((float) y)
                     * fCosa + f2 + 0.5); 
      int x0 = (long) ( ((float) x) * fCosa + ((float) y)
		* fSina + f1 + 0.5); 
      //判断是否在源图范围内 
      if( (x0 >= 0) && (x0 < nOldWidth) && (y0 >= 0) && (y0 < nOldHeight))
      {
        //用双线性插值
        if(bBilinear)
        {
          unsigned char *pTemp = Interpolation (nOldWidth,  nOldHeight,  
          (float)x0, (float)y0, nOldWidthBytes, nMovedBits, pOldBits);
          //复制像素
          memcpy(pNewTemp,  pTemp,  nMovedBits);
          delete ［］ pTemp ;
        }
        else
        {
          //指向源图像第y0行， 第x0个像素
          pOldTemp = pOldBits;
          pOldTemp += (nOldHeight - 1 - y0) * nOldWidthBytes;
          pOldTemp += x0 * nMovedBits;
          //复制像素
          memcpy(pNewTemp,  pOldTemp,  nMovedBits);
              }
         }
         pNewTemp += nMovedBits;
      }
  }
  //将内存解锁和将不再使用的内存释放， 将新图像设置为当前图像
  return TRUE;
} 
```

<img src="https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-12.jpg?height=1241&width=1792&top_left_y=196&top_left_x=402" style="zoom:25%;" />

图6-26 旋转前的图像



<img src="https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-13.jpg?height=1336&width=1661&top_left_y=129&top_left_x=432" style="zoom:25%;" />

图6-27 旋转 $15^{\circ}$ 并进行揷值处理的图像 

<img src="https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-14.jpg?height=1030&width=925&top_left_y=260&top_left_x=816" style="zoom: 25%;" />

图6-28 被放大的旋转前图像 

<img src="https://cdn.mathpix.com/cropped/2023_03_28_86df48ed620aaa1dabb8g-15.jpg?height=1356&width=1285&top_left_y=151&top_left_x=627" style="zoom: 25%;" />

6-29 旋转300并进行揷值处理的放大图像 



# 6.6 图像复合变换

## 6.6.1 图像复合变换

图像的复合变换是指对给定的图像连续施行若干次如前所述的平移、镜像、比例、旋转等基本变换后所完成的变换, 图像的复合变换又叫级联变换。利用齐次坐标, 对给定的图像依次按一定顺序连续施行若干次基本变换, 其变换的矩阵仍然可以用 $3 \times 3$ 阶的矩阵表示, 而且从数学上可以证明, 复合变换的矩阵等于基本变换的矩阵按顺序依次相乘得到的组合矩阵。设对给定的图像依次进行了基本变换 $F_{1}, F_{2}, \ldots, F_{N}$, 它们的变换矩阵分别为 $T_{1}, T_{2}, \ldots, T_{N}$, 按照公式 (6-1) $\sim$ (6-6) 的表示形式, 图像复合变换的矩阵 $T$ 可以表示为: $T=T_{N} T_{N-1} \ldots T_{1}$ 。 

### 复合平移

设某个图像先平移到新的位置 $P_{1}\left(x_{1}, y_{1}\right)$ 后, 再将图像平移到 $P_{2}\left(x_{2}, y_{2}\right)$ 的位置, 则复合平移矩阵为

$$
T=T_{1} T_{2}=\left[\begin{array}{ccc}

1 & 0 & x_{1} \\

0 & 1 & y_{1} \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{ccc}

1 & 0 & x_{2} \\

0 & 1 & y_{2} \\

0 & 0 & 1

\end{array}\right]=\left[\begin{array}{ccc}

1 & 0 & x_{1}+x_{2} \\

0 & 1 & y_{1}+y_{2} \\

0 & 0 & 1

\end{array}\right]\tag{6-7}
$$

由此可见, 尽管一些顺序的平移, 用到矩阵的乘法, 但最后合成的平移矩阵, 只需对平移常量作加法运算。 

### 复合比例

同样, 对某个图像连续进行比例变换, 最后合成的复合比例矩阵, 只要对比例常量作乘法运算即可。复合比例矩阵如下:

$$
T=T_{1} T_{2}=\left[\begin{array}{lll}

a_{1} & 0 & 0 \\

0 & d_{1} & 0 \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{lll}

a_{2} & 0 & 0 \\

0 & d_{2} & 0 \\

0 & 0 & 1

\end{array}\right]=\left[\begin{array}{lll}

a_{1} a_{2} & 0 & 0 \\

0 & d_{1} d_{2} & 0 \\

0 & 0 & 1

\end{array}\right]\tag{6-8}
$$

### 复合旋转

类似地, 对某个图像连续进行旋转变换, 最后合成的旋转变换矩阵等于两次旋转角度的和, 复合旋转变换矩阵如下式所示:

$$
\begin{aligned}

T & =T_{1} T_{2}=\left[\begin{array}{ccc}

\cos \theta_{1} & \sin \theta_{1} & 0 \\

-\sin \theta_{1} & \cos \theta_{1} & 0 \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{ccc}

\cos \theta_{2} & \sin \theta_{2} & 0 \\

-\sin \theta_{2} & \cos \theta_{2} & 0 \\

0 & 0 & 1

\end{array}\right] \\

& =\left[\begin{array}{ccc}

\cos \left(\theta_{1}+\theta_{2}\right) & \sin \left(\theta_{1}+\theta_{2}\right) & 0 \\

-\sin \left(\theta_{1}+\theta_{2}\right) & \cos \left(\theta_{1}+\theta_{2}\right) & 0 \\

0 & 0 & 1

\end{array}\right]

\end{aligned}\tag{6-9}
$$

上述均为相对原点(图像中央)作比例、旋转等变换, 如果要相对某一个参考点作变换，则要使用含有不同种基本变换的图像复合变换。不同的复合变换, 其变换过程不同, 但是无论它的变换过程多么复杂, 都可以分解成一系列基本变换。相应地, 使用齐次坐标后, 图像复合变换的矩阵由一系列图像基本几何变换矩阵依次相乘而得到。下面通过一个例子讨论含有不同种基本变换的图像复合变换。 

从6.2和6.5节的讨论中可以看出, 在进行图像的比例缩放、图像的旋转变换时, 整个变换过程由两部分组成, 即需要两个独立的算法。首先, 需要一个算法来完成几何变换本身, 用它描述每个像素如何从其初始位置移动到终止位置; 同时, 还需要一个用于灰度级插值的算法。这是因为, 在一般情况下, 原始 (输入) 图像的位置坐标 $(x, y)$ 为整数, 而变换后 (输出) 图像的位置坐标为非整数, 即产生 “空穴”，反过来也是如此。 因此, 一般地, 在进行图像的几何变换时, 除了要进行其本身的几何变换外，还要进行灰度级插值处理。 

灰度级插值处理可采用如下两种方法。第一，可以把几何变换想像成将输入图像的灰度一个一个像素地转移到输出图像中。 如果一个输入像素被映射到四个输出像素之间的位置, 则其灰度值就按插值算法在四个输出像素之间进行分配。把这种灰度级插值处理称为像素移交 (pixel carry over) 或称为向前映射法, 如图6-30所示。

另一种更有效的灰度级插值处理方法是像素填充(pixel filling)或称为向后映射算法。在这种算法中, 输出像素一次一个地映射回到原始(输入)图像中，以便确定其灰度级。如果一个输出像素被映射到四个输出像素之间, 则其灰度值由灰度级插值决定, 如图6-30所示。向后空间变换是向前变换的逆变换。 

![image-20230328161700646](https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328161700646.png)

图6-30 灰度级插值处理(像素变换)

在像素填充法中，变换后(输出)图像的像素通常被映射到原始(输入)图像中的非整数位置, 即位于四个输入像素之间。因此, 为了决定与该位置相对应的灰度值, 必须进行插值运算。最简单的插值方法是零阶插值或称为最近邻插值, 也叫最近邻域法, 参见本书6.2节。一阶插值或称双线性插值法和零阶插值法相比可产生更令人满意的效果, 只是程序稍复杂一些, 运行时间稍长一些。它的原理如图6-10和图6-31所示, 插值计算公式参见6.2.1中的公式(6-2)。由于篇幅所限, 双线性插值公式的推导在此从略, 有兴趣的读者请参考书后的参考文献。 

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328161720296.png" alt="image-20230328161720296" style="zoom:50%;" />

图6-31 双线性插值 

在这里还要说明一点, 为了提高双线性插值的速度, 双线性插值也可以分解为三个线性插值来实现, 公式如下:
$$
\begin{aligned}

& f(x, 0)=f(0,0)+x[f(1,0)-f(0,0)] \\

& f(x, 1)=f(0,1)+x[f(1,1)-f(0,1)] \\

& f(x, y)=f(x, 0)+y[f(x, 1)-f(x, 0)]

\end{aligned}\tag{6-10}
$$

因为公式(6-2)需要用到四次乘法、八次加(或减)法运算, 而公式(6-10)表示的第二种方法只需要三次乘法和六次加 (或减)法, 所以几何变换程序一般选择后者。从图6-31也可以看出双线性插值与最近邻插值的区别。 

在几何运算中，双线性灰度插值的平滑作用可能会使图像的细节产生退化, 尤其是在进行放大处理时, 这种影响将更为明显。而在其他应用中, 双线性插值的斜率不连续性会产生不希望得到的结果。这两种情况都可以通过高阶插值得到修正, 当然这需要增加计算量。使用高阶插值函数的例子有：三次样条、Legendre中心函数和 $\sin (\alpha x) / \alpha$ 函数(即 $\sin (\alpha x)$ 函数)。高阶插值常用卷积来实现, 这部分内容请读者参考书后所附的参考文献。 

## 6.6.2  图像复合变换的示例 

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230328161812903.png" alt="image-20230328161812903" style="zoom:67%;" />

图6-32 坐标系的平移 

两个坐标系之间的坐标变换矩阵表达式为:
$$
\left[\begin{array}{c}

x_{\Pi} \\

y_{\Pi} \\

1

\end{array}\right]=\left[\begin{array}{ccc}

1 & 0 & -a \\

0 & -1 & b \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{c}

x_{I} \\

y_{I} \\

1

\end{array}\right]
$$

它的逆变换矩阵表达式是:

$$
\left[\begin{array}{c}

x_{I} \\

y_{I} \\

1

\end{array}\right]=\left[\begin{array}{ccc}

1 & 0 & a \\

0 & -1 & b \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{c}

x_{\Pi} \\

y_{\Pi} \\

1

\end{array}\right]
$$

为了推导公式简单起见, 假设图像末旋转时中心坐标为 $(a,b)$, 旋转后中心坐标为 $(c, d)$ (在新的坐标系下旋转后新图像左上角为原点), 则旋转变换矩阵表达式为

$$
\begin{align}
\left[\begin{array}{c}
x \\
y \\
1
\end{array}\right]&=\left[\begin{array}{ccc}
1 & 0 & -c \\
0 & -1 & d \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{c}
x_{\Pi} \\
y_{\Pi} \\
1
\end{array}\right]=\left[\begin{array}{ccc}
1 & 0 & -c \\
0 & -1 & d \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{ccc}
\cos \theta & \sin \theta & 0 \\
-\sin \theta & \cos \theta & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{c}
x_{\Pi} \\
y_{\Pi} \\
1
\end{array}\right]\\
&=\left[\begin{array}{ccc}
1 & 0 & -c \\
0 & -1 & d \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{ccc}
\cos \theta & \sin \theta & 0 \\
-\sin \theta & \cos \theta & 0 \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{ccc}
1 & 0 & -a \\
0 & -1 & b \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{c}
x_{0} \\
y_{0} \\
1
\end{array}\right]
\end{align}
\tag{6-11}
$$

$$

$$

其逆变换表达式为

$$
\left[\begin{array}{c}

x_{0} \\

y_{0} \\

1

\end{array}\right]=\left[\begin{array}{ccc}

1 & 0 & -a \\

0 & -1 & b \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{ccc}

\cos \theta & \sin \theta & 0 \\

-\sin \theta & \cos \theta & 0 \\

0 & 0 & 0

\end{array}\right] \cdot\left[\begin{array}{ccc}

1 & 0 & -c \\

0 & -1 & d \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{c}

x \\

y \\

1

\end{array}\right]\tag{6-12}
$$
即
$$
\left[\begin{array}{c}

x_{0} \\

y_{0} \\

1

\end{array}\right]=\left[\begin{array}{ccc}

\cos \theta & \sin \theta & -c \cos \theta-d \sin \theta+a \\

-\sin \theta & \cos \theta & c \sin \theta-d \cos \theta+b \\

0 & 0 & 1

\end{array}\right] \cdot\left[\begin{array}{c}

x \\

y \\

1

\end{array}\right]\tag{6-13}
$$

因此

$$
\left\{\begin{array}{l}
x_{0}=x \cos \theta+y \sin \theta-c \cos \theta-d \sin \theta+a \\
y_{0}=-x \sin \theta+y \cos \theta+c \sin \theta-d \cos \theta+b
\end{array}\right.\tag{6-14}
$$

公式(6-10)说明绕任意点(a,b)旋转的几何变换是由平移一旋转一平移三个基本变换所构成, 即先将坐标系平移到点( $a$,b), 再进行旋转, 然后将旋转后的图像平移回原来的坐标原点。 

利用上面的转换公式 $(6-12) \sim(6-14) ，$ 就可以比较方便地编㝍出实现图像旋转的VC++函数。首先应计算出公式中需要的几个参数: $a, b, c, d$ 和旋转后新图像的高、宽度。现在已知图像的原始宽度为lWidth, 高度为lHeight, 以图像中心为坐标系原点，则原始图像四个角的坐标分别为

$$
\begin{aligned}
& {\left[-\frac{\text { lWidth }-1}{2}, \frac{\text { lHeight }-1}{2}\right],\left[\frac{\text { lWidth }-1}{2}, \frac{\text { lHeight }-1}{2}\right]} \\
& {\left[\frac{\text { lWidth }-1}{2},-\frac{\text { lHeight }-1}{2}\right],\left[-\frac{\text { lWidth }-1}{2},-\frac{\text { lHeight }-1}{2}\right]}
\end{aligned}
$$

按照旋转公式(6-11) (6-14), 在旋转后的新图像中, 这四个点坐标为

$$
\begin{aligned}
& (f D s t X 1, f D s t Y 1)=\left(-\frac{l \text { Width }-1}{2} \cos \theta+\frac{\text { lHeight }-1}{2} \sin \theta,-\frac{l \text { Width }-1}{2} \sin \theta+\frac{\text { lHeight }-1}{2} \cos \theta\right) \\
& (f D s t X 2, f D s t Y 2)=\left(\frac{l \text { Width }-1}{2} \cos \theta+\frac{l \text { Height }-1}{2} \sin \theta,-\frac{l \text { Width }-1}{2} \sin \theta+\frac{\text { lHeight }-1}{2} \cos \theta\right) \\
& (f D s t X 3, f D s t Y 3)=\left(-\frac{l \text { Width }-1}{2} \cos \theta-\frac{l \text { Height }-1}{2} \sin \theta,-\frac{l \text { Width }-1}{2} \sin \theta-\frac{l \text { Height }-1}{2} \cos \theta\right) \\
& (f D s t X 4, f D s t Y 4)=\left(-\frac{l W i d t h-1}{2} \cos \theta-\frac{l \text { Height }-1}{2} \sin \theta, \frac{l \text { Width }-1}{2} \sin \theta-\frac{l \text { Height }-1}{2} \cos \theta\right)
\end{aligned}
$$

则新图像的宽度lNewWidth和高度lNewHeight为

$$
lNewWidth =\max (|f D s t X 4-f D s t Y 1|,|f D s t X 3-f D s t Y 2|)\\
lNewHeight =\max (|f D s t X 4-f D s t Y 1|,|f D s t X 3-f D s t Y 2|)
$$

如果令

$$
\left\{\begin{array}{l}
f_{1}=-c \cos \theta-d \sin \theta+a \\
f_{2}=c \sin \theta-d \cos \theta+b
\end{array}\right.\tag{6-15}
$$

由已知及假设

$$
a=\frac{\text { lWidth }-1}{2}, b=\frac{\text { lHeight }-1}{2}, c=\frac{\text { lNewWidth }-1}{2}, d=\frac{\text { lNewHeight }-1}{2}
$$

由公式 (6-13) 得

$$
\left\{\begin{array}{l}
x_{0}=x \cos \theta+y \sin \theta+f_{1} \\
y_{0}=-x \sin \theta+y \cos \theta+f_{2}
\end{array}\right.\tag{6-16}
$$

公式 (6-16)、(6-17) 便是图像绕任意点 $(a, b)$ 旋转的变换公式, 由此便可以编㝍出实现该变换的VC++程序。事

实上，只要先按上述公式计算出旋转后新图像的高度和宽度以及常数 $f 1$ 和 $f_{2}$, 并按照公式 (6-17) 计算出变换后图像上的点 $(i 0, j 0)$ :

$/ /$ 计算该像素在源DIB中的坐标

$$
\begin{aligned}
& i 0=-((\text { float }) j) * f \operatorname{sina}+((\text { float }) i) * f \operatorname{cosa}+f 2 \\
& j 0=((\text { float }) j) * f \text { cosa }+((\text { float }) i) * f \sin a+f 1
\end{aligned}
$$

# 6.7 透视变换

## 6.7.1 透视变换

把三维物体或对象转变为二维图形表示的过程称为投影变换。

根据视点 (投影中心) 与投影平面之间距离的不同, 投影可分为平行投影和透视投影, 透视投影即透视变换。平行投影的视点与投影平面之间的距离为无穷大, 而对透视投影(变换), 该距离是有限的。这个距离决定着透视投影的特性一透视缩小效应, 即三维物体或对象透视投影的大小与形体到视点的距离成反比。 例如, 等长的两直线段, 都平行于投影面, 但离投影中心近的线段, 其透视投影大, 而离投影中心远的线段, 透视投影小。这种效应所产生的视觉效果与照相机系统和人的视觉系统十分类似。 与平行投影相比, 透视投影的深度感更强, 看上去更真实, 但透视投影不能真实地反映物体的精确尺寸和形状。 

对于透视投影，一束平行于投影面的平行线的投影可保持平行, 而不平行于投影面的平行线的投影会聚集到一个点, 这个点称为灭点 (Vanishing Point)。灭点可以看作是无限远处的一点在投影面上的投影。透视投影的灭点可以有无限多个, 不同方向的平行线在投影面上就能形成不同的灭点, 坐标轴方向的平行线在投影面上形成的灭点又称作主灭点。因为有 $x, y$ 和 $z$ 三个坐标轴, 所以主灭点最多有 3 个。透视投影是按主灭点的个数来分类的, 即按投影面与坐标轴的夹角来分类的, 可分为一点透视、二点透视和三点透视, 如图6-33 所示。 

![image-20230428094524158](https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230428094524158.png)

图6-33 透视变换 (a)一点透视；  (b) 二点透视;  (c) 三点透视

下面讨论一点透视。一点透视只有一个主灭点，即投影面与一个坐标轴正交，与另外两个坐标轴平行，如图6-33(a)所示。 进行一点透视投影变换，要很好地考虑图面布局, 以避免三维形体或对象的平面域积聚成直线或直线积聚成点而影响直观性。具体地说，就是要考虑下列几点： (1)三维形体或对象与画面 (投影面)的相对位置；(2)视距，即视点与畐面的距离；(3)视点的高度。 由此，假设视点在坐标原点， $Z$ 坐标轴方向与观察方向重合一致， 三维形体或对象上某一点为 $P(x, y, z)$, 一点透视变换后在投影面 (观察平面) $U O^{\prime} V$ 上的对应点为 $P^{\prime}\left(x^{\prime}, y^{\prime}, z^{\prime}\right)$, 投影面与 $z$ 轴垂直, 且与视点的距离为d， $z$ 轴过投影面窗口的中心，窗口是边长为 $2 S$ 的正方形, 如图6-34所示。根据相似三角形对应边成比例的关系, 有: 

$$
\begin{gathered}
\frac{x^{\prime}}{x}=\frac{y^{\prime}}{y}=\frac{z^{\prime}}{z}, z^{\prime}=d \\
x^{\prime}=\frac{x}{z} d, y^{\prime}=\frac{y}{z} d, z^{\prime}=d
\end{gathered}\tag{6-18}
$$

利用齐次坐标, 与二维几何变换类似, 将该过程写成变换矩阵形式为

$$
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
z^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{llll}
d & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & 0 & -1 \\
0 & 0 & 1 & 0
\end{array}\right] \cdot\left[\begin{array}{l}
d x \\
d y \\
-1 \\
z
\end{array}\right]\tag{6-19}
$$



<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230428094807312.png" alt="image-20230428094807312" style="zoom:50%;" />

图6-34 一点透视变换

一般地, 视点不在原点, 投影平面是任意平面的情况,一点透视变换的矩阵也可以用一个 $4 \times 4$ 的矩阵表示。当根据公式 (6-19) 求出它的逆变换后, 可以用 $VC++$ 编写一个实现图像透视的程序, 实现图像的透视。 

## 6.7.2 其他变换

如前所述, 齐次坐标为确定各种基本变换和复合变换公式提供了一个简单的方法。然而, 在许多图像处理与分析应用中, 所需的几何变换都相当复杂, 甚至有些无法用简便的数学式来表达。此外, 所需几何变换经常要从对实际图像的测量中获得, 因此更希望用这些测量结果而不是函数形式来描述几何变换。 例如, 在对由摄像机拍摄的有几何畸变的图像进行几何校正时, 首先应将一个矩形栅格目标数字化并显示出来。因为摄像机中有几何变形, 所显示的图案不会是准确的矩形, 因此所求几何变换应能使其栅格图案再次被复原为准确的矩形, 从而修正了摄像机产生的畸变。采用同样的几何变换可用于校正同一摄像机生成的数字化图像(假定畸变与景物无关), 由此可得到不畸变的图像。 

图像几何变换的一个重要应用是消除由于摄像机导致的数字图像的几何畸变。当需要从数字图像中得到定量的空间测量数据时, 几何校正被证明是十分重要的。某些图像, 例如, 从卫星上或飞机侧视雷达上得到的图像, 都有相当严重的几何变形, 这些图像需要先经过几何校正，然后才能对其内容做出解释。一些图像系统使用非矩形的像素坐标, 例如, 极坐标、柱坐标、 球面坐标等, 用普通的显示设备观察这些图像时, 必须先对它们进行校正, 也就是说, 将其转换为矩形像素坐标。例如, 在油 (水) 井套管缺陷识别中, 有时需要将极坐标系中的内突镜图像转换为直角坐标系中的图像, 然后进行分析与处理, 如图6-35、 6-36所示。 

<img src="https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230428094837780.png" alt="image-20230428094837780" style="zoom:33%;" />

图6-35 极坐标系中的内突镜图像

![image-20230428094904309](https://mypic-1312707183.cos.ap-nanjing.myqcloud.com/image-20230428094904309.png)

图6-36 转换为直角坐标系中的图像

有时机器人的鱼眼透镜拍摄的变形严重的一幅图像, 也可以设计一个适当的几何变换将其校正到矩形坐标系统, 这样, 可用立体视觉测距技术对机器人周围的物体进行三维空间定位。

几何变换的另一个应用是对相似的图像进行配准, 以便进行图像比较, 典型的应用是利用图像相减来检测运动或变化。 有时, 为便于解释需将图像以另一种样式表示, 这时也会用到几何变换, 地图绘制中的图像投影也会用到几何变换。例如, 在利用从宇宙飞船传回来的图像, 拼成地球、月球及行星的航拍镶嵌地图时, 就必须用几何变换。有关这些变换及其应用的详细内容请参阅书后的参考文献。 

# 6.8 应用实例

下面给出图像几何变换应用的一个例子一图像的转置。像的转置是将给定图像像素的x坐标和y坐标互换的几何变换。

图像的转置和图像的旋转不同, 而且仅仅通过旋转是不可能实现图像转置的。旋转操作与镜像操作结合才能实现图像的转置。图像转置的方法如下: 

首先将图像水平镜像, 然后逆时针旋转 $90^{\circ}$ 才可以实现。设点 $P_{0}\left(x_{0}, y_{0}\right)$ 进行转置后的对应点为 $P(x, y)$, 图像高度为 $f H e i g h t$, 宽度为fWidth, 原图像中 $P_{0}\left(x_{0}, y_{0}\right)$ 经过转置后坐标将变为 $\left(y_{0}, x_{0}\right)$ 。 如果把图像转置看作是图像镜像与旋转的复合, 并且图像的水平镜像在 $x$ 方向不作平移。此时, 6.4.1中的公式 (6-4) 变为
$$
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{rrr}
-1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]
$$

根据此式及6.5.1中的公式 (6-6) 可得

$$
\begin{aligned}
& {\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{rrr}
\cos \theta & \sin \theta & 0 \\
-\sin \theta & \cos \theta & 0 \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{rrr}
-1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]\left(\theta=90^{\circ}\right)} \\
& {\left[\begin{array}{l}
x \\
1
\end{array}\right]=\left[\begin{array}{rrr}
0 & 1 & 0 \\
-1 & 0 & 0 \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{rrr}
-1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]=\left[\begin{array}{lll}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{array}\right] \cdot\left[\begin{array}{l}
x_{0} \\
y_{0} \\
1
\end{array}\right]}
\end{aligned}\tag{6-20}
$$

公式(6-20)就是图像转置的变换公式。 

事实上，(6-19) 也可以直接得到, 因为原图像中 $P_{0}\left(x_{0}, y_{0}\right)$ 经过转置后坐标将变为 $P\left(y_{0}, x_{0}\right)$, 即 $x=y_{0}, y=x_{0}$, 把这个关系用齐次坐标写成矩阵形式就是式(6-20)。

图像转置的实现和图像镜像变换类似, 不同之处在于图像转置后DIB的头文件也要进行相应的改变, 主要是将头文件中图像高度和宽度信息更新。因此传递给图像转置函数的参数是直接指向DIB的指针, 而不是直接指向DIB像素的指针。下面给出实现图像转置函数TransposeDIB()的框架和主要算法。

```verilog
//******************************************
// 函数名称： BOOL Transpose()
// 基本功能： 本函数对传入的CDibObject对象中的图像进行转置操作
// 参数说明： CDibObject *pDibObject  默认为NULL
// 返回值: BOOL  转置成功返回TRUE， 否则返回FALSE
//******************************************
BOOL CGeoTrans: : Transpose(CDibObject *pDibObject)
{
  //定义指向源图像及新图像的指针、 位图数据指针、 调色板等指针变量
  //获取源图像指针及文件头、 信息头、 调色板及图像数据等信息
  //计算新图像大小(包括文件头、 信息头、 调色板和图像数据) 
  //为新图像分配内存， 指定新图像的文件头、 信息头、 调色板及图像数据指针
  //用255填充新图像数据区， 用源图像的文件头、 信息头填充相应的新图像
  //调整文件总字节数、 新图像的宽度和高度等信息， 用原调色板填充新调色板
  //由图像位数确定的移动字节数
  int nMovedBits = 1;
  switch( m_pDibObject->GetNumBits() )
  {
  case 8:	
    nMovedBits = 1;
    break;
  case 16:
    nMovedBits = 2;
    break; 
case 24:
    nMovedBits = 3;
    break;
case 32:
    nMovedBits = 4;
    break;
  }
  // 针对图像每行进行操作
  for(y = 0; y < nOldHeight; y++)
  {
    //指向源图像第y行
    pOldTemp = pOldBits;
    pOldTemp += (nOldHeight -1 -y) * nOldWidthBytes;
    // 针对每行图像每列进行操作 
 for(x = 0; x < nOldWidth; x++)
    {
      //指向转置后的图像第x行， 第y个像素的指针
      pNewTemp = pNewBits;
      pNewTemp += (nNewHeight -1 -x) * nNewWidthBytes;
      pNewTemp += y * nMovedBits;
      //复制像素
      memcpy(pNewTemp,  pOldTemp,  nMovedBits);
      pOldTemp += nMovedBits;
    }
  }
   //将内存解锁和将不再使用的内存释放，将新图像设置为当前图像，返回TRUE
} 

```

<img src="https://cdn.mathpix.com/cropped/2023_03_28_0a2d55a860b6bebbbba9g-26.jpg?height=1101&width=986&top_left_y=234&top_left_x=808" style="zoom: 25%;" />

图6-37 转置后的图像

